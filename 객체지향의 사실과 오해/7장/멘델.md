# 7장) 함께 모으기

마틴 파울러의 개념관점, 명세관점, 구현관점의 객체지향 설계

⇒ 동일한 클래스를 세 가지 다른 방향에서 바라보는 것을 말한다

### 개념 관점

도메인이란, 사용자들이 관심을 가지고 있는 특정 분야나 주제를 말하며 소프트웨어는 도메인에 존재하는 문제를 해결하기 위해 개발된다.

개념관점은 사용자가 도메인을 바라보는 관점을 반영해서 객체지향을 설계하는 것이다.

⇒ 실제 도메인 규칙, 제약을 유사하게 반영한다

### 명세 관점 ⇒ 객체의 인터페이스를 만드는데 사용되는 관점. 협력

개발자의 소프트웨어 관점에서 바라보는 것.

즉, 실제 소프트웨어 안에서 살아 숨쉬는 객체들의 책임에 초점을 맞춘 관점

객체가 협력을 위해 무엇을 할 수 있는지에 초점을 맞추는 것

⇒ 인터페이스와 클래스 구현을 구분지으면 좀 더 객체지향 설계를 잘 할 수 있다.

### 구현 관점

코드와 연관된 관점

객체들이 책임을 수행하는데 필요한 동작 코드를 작성하는 것

객체의 책임을 어떻게 수행시킬 것인지에 초점을 맞추면서 인터페이스를 구현하기 위한 속성과 메소드를 추가한다

클래스 그 자체는 도메인 관점을 은유해야 하며, 그 클래스의 인터페이스는 명세 관점을 반영해야 하며, 클래스의 속성과 메소드는 구현 관점을 반영해야 한다.

## 클래스

클래스는 위의 세 가지 관점을 모두 수용할 수 있도록 개념, 인터페이스, 구현을 함께 드러내야 한다.

역할, 책임, 협력을 중점적으로 생각하자.

# 커피 전문점 도메인

객체지향 관점에서 모든 것은 객체이다. 메뉴판 조차도….

손님 객체가 메뉴판 객체가 가진 메뉴 항목 객체들 중 한 객체를 바리스타에게 넘겨준다.

바리스타는 자율적으로 커피를 제조한다.

바리스타가 제조하는 커피 역시 명확한 자신만의 경계를 가지므로 객체로 볼 수 있다.

⇒ 손님과 메뉴판, 손님과 바리스타…. 각각 사이에는 관계가 존재한다.

### 도메인 설계하기

동적인 객체를 정적인 타입으로 추상화해서 복잡성을 낮춰서 바라본다.

즉, 타입은 분류를 위해 사용되는 것이다.

메뉴판 타입은 메뉴 항목 타입을 여러개 포함하고 있는 관계다. 이를 **포함 관계** 혹은 **합성 관계** 라고한다.

이런 경우는 속이 찬 마름모로 표현한다.

손님 타입은 메뉴판 타입을 알고 있어야 한다. 하지만 이는 일부 관계가 아니므로 합성관계가 아니다.

이런 경우는 단순한 선으로만 표현한다.

⇒ 한 인스턴스가 다른 타입의 인스턴스를 포함은 하지 않지만 알아야 하는 경우에 **연관관계** 라고 한다

도메인 모델을 작성하는 단계에서는 연관, 포함 관계 이런 것은 중요하지 않다. 초점은 도메인을 구성하는 타입들을 찾아내고, 그 타입들 간 관계가 존재한다는 것만 알아도 된다.

### 설계하기 ⇒ 훌륭한 객체를 만드는 것이 아니라 **훌륭한 협력을 설계하는 것이 중요하**다

협력을 설계하는 법

1. 메시지가 객체를 선택해서 찾아가서 그 객체 아래에 해당 메시지가 구성요소로 놓이도록 해라.

   그러면, 해당 객체가 그 메시지를 처리할 책임을 맡게 되는것이다.

2. 메시지를 찾았으면 누구에게 줘야할까? 위에서 설계한 도메인 모델을 토대로 메시지를 수신할 객체를 찾자.

손님은 주문해야할 메뉴 이름과 함께 커피를 주문할 메시지를 수신 받았지만, 메뉴 항목을 몰라서 해당 메시지를 처리할 수 없다.

즉, 손님은 찾고자 하는 메뉴 이름과 매칭되는 메뉴 항목을 얻어야 한다. 이를 위해서 다른 객체(메뉴판 객체)에게 메시지를 보내서 협력해야 한다.

메뉴판 객체가 메뉴 항목들을 가장 잘알고 매칭되는 메뉴 항목을 반환할 수 있기 때문에 해당 메시지의 책임을 맡은 것이다.(메뉴판은 현실 세계와 달리 수동적이 아니라 자율적으로 손님이 찾고자 하는 메뉴와 매칭되는 메뉴 항목을 찾을 것이다)

UML은 의사소통의 도구일 뿐, 꼭 지켜야 하는 것은 아니다.

### 메시지를 수신할 객체들을 모두 정했다면, 이제 얻은 인터페이스를 정리해라

# 구현하기

그렇다면, 고객은 메뉴 객체와 바리스타 객체에게 메시지를 보내야 하는데, 해당 객체들에 대한 참조를 고객이 어떻게 얻어야 할까?

일반적으로는 메소드의 인자로 도움을 요청할 객체를 전달받는다. ⇒ 이렇게 참조를 얻겠다는 결정으로 인해서 고객의 인터페이스가 변경된다.

**구현 도중에 객체의 인터페이스는 얼마든지 변경될 수 있음을 기억하자.**

메뉴판 클래스에 메뉴아이템이 리스트로 속성으로써 존재하는 것도 클래스를 구현하는 도중에 내려진 결정이다.

이렇게 해야 해당 객체의 인터페이스로 속성이 노출되지 않고 캡슐화가 잘 된다.

바리스타는 받은 메뉴항목 객체를  사용해서 커피 객체를 만든다. 커피객체는 속성으로 커피 이름과 가격을 갖는데, 이 값들은 생성자 단계에서 받은 메뉴항목으로부터 얻어온다.

즉, 메뉴항목은 그 메뉴의 이름과 가격을 제공하는 메소드를 지녀야 한다.

인터페이스의 구성도 동적으로 구현하다가 추가된 것을 알 수 있다. 처음부터 완벽한 설계는 할 수 없다. 필요하면 추가하는 것이다. 너무 많은 시간을 설계에 투자하지말고 코드로 직접 구현해봐라.

# 코드와 세가지 관점

개념 관점, 명세 관점, 구현 관점은 동일한 코드를 바라보는 서로 다른 관점이다.

### 개념관점

**개념 관점**에서 코드를 바라보면 클래스들을 떠올리면 된다.

이 개념관점에서 설계한 클래스들 중 변경이 가능할 것 같은 클래스들을 찾아보면 된다.

커피 제조 과정이 변경 가능할 것 같다. 그렇다면 변경 가능한 클래스는 바리스타일 것이다.

sw클래스와 도메인 타입 사이 간격이 좁을수록 기능을 변경하기 위한 코드의 양도 줄어들 것이다.

### 명세관점

**명세관점**에서 클래스의 인터페이스를 바라본다.

객체의 인터페이스는 변경을 하지 않는게 가장 좋다. 다른 객체들에 너무 큰 영향이 가기 때문이다.

### 구현관점

클래스의 내부 구현을 바라본다. 클래스의 메소드와 속성은 구현부분이다. 메서드의 구현과 속성을 변경하는 것이 다른 객체에게 영향을 주면 안된다. 즉, 외부 클래스가 자신이 협력하는 다른 클래스의 비밀 때문에 우왕좌왕해서는 안된다는 것이다.

⇒ 이 세 관점을 명확하게 드러낼 수 있는 코드를 작성해라.

# 도메인 개념을 참조하는 이유

메시지를 수신할 객체를 찾고 싶다면 가장 쉬운 전략은 도메인 개념에서 고르는 것이다. 이렇게 하면 도메인 지식을 바탕으로 코드를 쉽게 간파할 수 있다.

또한, 도메인 개념이 변경되었을때 이를 따르는 코드는 쉽게 변경 가능할 것이다.

### 인터페이스와 구현을 분리해라.

명세 관점과 구현 관점이 뒤섞여서 복잡하게 생각하지 말아라.

명세 관점은 클래스의 안정적인 측면을 드러내야 한다.

구현 관점은 클래스의 불안정한 측면을 드러내야 한다.

인터페이스가 구현 세부 사항을 노출하기 시작하면 작은 변동에도 전체 협력이 요동치는 취약한 설계를 얻게 된다.

마틴 파울러가 명세관점과 구현관점의 분리는 너무나도 중요하다고 강조한다고 합니다.
