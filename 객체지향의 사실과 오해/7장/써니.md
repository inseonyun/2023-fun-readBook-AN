# 함께 모으기

코드와 모델을 밀접하게 연관시키는 것은 코드에 의미를 부여하고 모델을 적절하게 한다.

마틴 파울러 왈..
객체지향 설계 안에 존재하는 세 가지 상호 연관된 관점에 관해 설명한다. 각각 개념, 명세, 구현 관점이라 부른다.

개념 관점에서 설계는 도메인 안에 존재하는 개념과 개념들 사이의 관계를 표현한다.
> 도메인이란 사용자들이 관심을 가지고 있는 특정 분야나 주제를 말하며 소프트웨어는 도메인에 존재하는 문제를 해결하기 위해 개발된다. 이 관점은 사용자가 도메인을 바라보는 관점을 반영합니다. 따라서 실제 도메인의 규칙과 제약을 최대한 유사하게 반영하는것이 핵심이다.

명세 관점에 이르면 사용자의 영역인 도메인을 벗어나 개발자의 영역인 소프트웨어로 초점이 옮겨진다.
> 명세관점은 도메인의 개념이 아니라 실제로 소프트웨어 안에서 살아 숨쉬는 객체들의 책임에 초점을 맞추게 된다. 객체의 인터페이스를 바라보게 된다. 명세 관점에서 프로그래머는 객체가 협력을 위해 '무엇'을 할 수 있는가에 초점을 맞춘다. 인터페이스와 구현을 분리하는 것은 훌륭한 객체지향 설계를 낳는 가장 기본적인 원칙이다.

구현 관점은 객체들이 책임을 수행하는 데 필요한 동작하는 코드를 작성하는 것이다. 따라서 프로그래머는 객체의 책임을 '어떻게' 수행할 것인가에 초점을 맞추며 인터페이스를 구현하는 데 필요한 속성과 메서드를 클래스에 추가한다.

클래스는 세 가지 관점을 모두 수용할 수 있도록 개념, 인터페이스, 구현을 함께 드러내야 한다. 동시에 코드 안에서 세 가지 관점을 쉽게 식별할 수 있도록 깔끔하게 분리해야 한다.


## 커피 전문점 도메인
### 커피 전문점이라는 세상
인간의 두뇌는 세상을 이해하기 위해 객체를 직접적으로 다룰 수 있을만큼 효율적이지 못하다.
-> TODO : 동적인 객체를 정적인 타입으로 추상화해서 복잡성을 낮추는 것
타입은 분류를 위해 사용된다. 상태와 무관하게 동일하게 행동할 수 있는 객체들은 동일한 타입의 인스턴스로 분류할 수 있다.
>  메뉴 항목 타입 and 커피 타입: 아메리카노, 에스프레소.... / 손님 타입: 손님 / 바리스타 타입: 바리스타

포함 또는 합성 관계
> 메뉴 항목은 메뉴판에 포함된다.

연관 관계
> 손님은 메뉴판 타입을 알고 있어야 한다. 이는 한 타입의 인스턴스가 다른 타입의 인스턴스를 포함하지는 않지만 서로 알고 있는 관계이다.
> 바리스타 타입은 커피를 제조하기 위해 커피 타입을 알고 있어야 한다. 
> 손님과 바리스타 타입 역시 서로 포함되진 않지만 알고 있어야 한다.


## 설계하고 구현하기
### 커피를 주문하기 위한 협력 찾기
협력을 설계할 때는 객체가 메시지를 선택하는 것이 아니다!!! 메시지가 객체를 선택하게 해야 한다!!!
--> 메시지를 수신하기에 적절한 객체를 선택해야 한다! 그럼 수신할 객체는 그 메시지를 처리해야할 책임을 맡게 되고 객체가 수신하는 메시지는 객체가 외부에 제공하는 공용 인터페이스에 포함된다.
> 커피 전문점에서 메시지는 '커피를 주문하라'이고, 이 메시지를 처리할 책임은 누구일까? 손님이지~

이때, 손님이 할당된 책임을 수행하는 도중에 스스로 할 수 없는 일이 있다면 다른 객체에게 이를 요청해야 한다.
이 요청이 바로 손님 객체에서 외부로 전송되는 메시지를 정의한다.
> 손님은 메뉴 항목은 모른다. 메뉴 항목은 메뉴판의 일부고, 손님은 메뉴판을 알고 있다. 그러므로, 메뉴판에게 메뉴 항목을 찾으라는 메시지를 메뉴 이름과 함께 전달하고 그를 통해 메뉴 항목을 받게 될 것이다.

손님은 주문한 커피에 대한 메뉴 항목을 통해 '커피를 제조하라'라는 메시지를 요청하게 된다. 이때, 메뉴 항목을 주며 반환 값으로는 커피를 받게 될 것이다.
> 당연히 커피는 바리스타가 제조한다

바리스타는 커피 타입 객체에게 '생성하라'라는 메시지를 던져 커피를 생성하여 손님에게 반환하게 된다.

### 인터페이스 정리하기
객체가 수신한 메시지가 객체의 인터페이스를 결정한다.
메시지가 객체를 선택했고, 선택된 객체는 메시지를 자신의 인터페이스로 받아들인다.
각 객체를 협력이라는 문맥에서 떼어내어 수신 가능한 메시지만 추려내면 객체의 인터페이스가 된다. 객체가 어떤 메시지를 수신할 수 있다는 것은 그 객체의 인터페이스 안에 메시지에 해당하는 오퍼레이션이 존재한다는 것을 의미한다.
> 손님 객체 인터페이스 안에는 '커피를 주문하라'라는 오퍼레이션이 포함돼야 한다. 등...


### 구현하기
손님은 메뉴판(메뉴 이름)을 통해 메뉴(아이템)을 받아 바리스타에게 전달해 커피를 제조하도록 요청해야 한다.
어떻게 메뉴, 바리스타에 접근할 것인가?
-> 객체에 대한 참조를 얻어야 하므로, 어떤 방법으로든 손님과 협력하는 메뉴, 바리스타 객체에 대한 참조를 알고 있어야 한다.
> 저자는 메뉴와 바리스타를 인자로 받아 해결했다. 이는 손님의 인터페이스를 변경한다.
> 저자 왈.. 구현 도중에 객체의 인터페이스가 변경될 수 있다는 점을 눈여겨보라.
> 구현하지 않고 머릿속으로만 구상한 설계는 코드로 구현하는 단계에서 대부분 변경된다. 협력을 구상하는 단계에 너무 시간을 쏟지 말고 최대한 빨리 코드를 구현해서 설계에 이상이 없는지, 설계가 구현 가능한지 판단해야 한다.

'메뉴'는 '메뉴 이름'에 해당하는 '메뉴 아이템'을 찾아야 하는 책임이 있다. 이 책임을 수행하기 위해서는 메뉴가 내부적으로 '메뉴 아이템'을 관리하고 있어야 한다.
> 저자는 리스트 프로퍼티로 메뉴 아이템을 갖고 있게 했다.
> 저자 왈.. 메뉴 아이템의 목록을 메뉴의 속성으로 포함시킨 결정 역시 클래스를 구현하는 도중에 내려졌다는 사실에 주목하라.
> 객체의 속성은 객체의 내부 구현에 속하기 때문에 캡슐화돼야 한다. --> 인터페이스에는 객체의 내부 속성에 대한 어떤 힌트도 제공돼서는 안 된다.
> 이를 위한 훌륭한 방법은 인터페이스를 정하는 단계에서는 객체가 어떤 속성을 가지는지, 또 그 속성이 어떤 자료 구조로 구현됐는지를 고려하지 않는 것이다.
> 객체에게 책임을 할당하고 인터페이스를 결정할 때는 가급적 객체 내부의 구현에 대한 어떤 가정도 하지 말아야 한다.


## 코드와 세 가지 관점
### 코드는 세 가지 관점을 모두 제공해야 한다.
개념 관점_소프트웨어 클래스와 도메인 클래스 사이의 간격이 좁으면 좁을수록 기능을 변경하기 위해 뒤적거려야 하는 코드의 양도 점점 줄어든다.

명세 관점_클래스의 인터페이스를 바라본다. 객체의 인터페이스는 수정하기 어렵다. 최대한 변화에 안정적인 인터페이스를 만들기 위해서는 인터페이스를 통해 구현과 관련된 세부 사항이 드러나지 않게 해야 한다.

구현 관점_클래스의 내부 구현을 바라본다. 메서드의 구현과 속성의 변경은 원칙적으로 외부의 객체에게 영향을 미쳐서는 안 된다.(파급효과가 미치는 것을 막는 것이 불가능한 경우도 있음) 즉, 이 말은 메서드와 속성이 철저하게 클래스 내부로 캡슐화 돼야 한다는 것을 의미한다. 메서드와 속성은 클래스 내부의 비밀이다.


### 도메인 개념을 참조하는 이유
도메인에 대한 지식을 기반으로 코드의 구조와 의미를 쉽게 유추할 수 있게 한다!


### 인터페이스와 구현을 분리하라
저자 왈.. 강조한다. **인터페이스와 구현을 분리하라.**


