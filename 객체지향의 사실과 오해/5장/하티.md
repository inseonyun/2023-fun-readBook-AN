## 자율적인 책임

- **자율적**인 객체
    - 스스로 정한 원칙에 따라 판단하고 스스로의 의지를 기반으로 행동하는 객체
    - 스스로의 의지와 판단에 따라 각자 맡은 책임을 수행하는 객체
- 책임: 요청을 처리하기 위해 객체가 수행하는 행동
- 객체가 자율적으로 책임을 수행하기 위해서는 → 객체에게 할당되는 **책임도 자율적**이어야 함
- 자율적 vs 추상적 책임
    - 너무 구체적이면 자율적이지 못함
    - 너무 추상적이면 협력의 의도를 명확하게 표현할 수 없음
    - 즉, 협력에 참여하는 의도를 명확하게 설명할 수 있는 수준 안에서 추상적이어야 함 !
- 책임은 객체가 어떻게 해야 하는가가 아닌, **무엇을 해야 하는가**를 설명해야 함

<br/>

## 메시지

- 메시지—전송 메커니즘은 객체가 다른 객체에 접근할 수 있는 유일한 방법
- 메시지 = 메시지 이름 + 인자
- 메시지 전송 = 수신자 + 메시지 = 수신자 + 메시지 이름 + 인자
    - 수신자.메시지이름(인자)
- 메시지 전송을 통해 다른 객체의 책임을 요청할 수 있고,
    
    메시지 수신을 통해 자신의 책임을 수행할 수 있다.
    
- 메시지의 모양 = 객체가 수행할 책임의 모양
- 메시지를 처리하기 위한 방법은 객체가 자율적으로 선택
- 외부 객체는 메시지에 관해서만 볼 수 있고, 객체 내부는 볼 수 없음 → 객체의 내부와 외부 분리

<br/>

## 메서드

- 메시지를 처리하기 위해 내부적으로 선택하는 방법
- 클래스 안에 포함된 함수 또는 프로시저를 통해 구현됨
- 메시지 수신 → 메시지 처리 가능 여부 확인 → 메서드 선택 → 메서드 실행
- 메시지를 수신한 객체가 실행 시간에 메서드를 선택할 수 있다

<br/>

## 다형성

- 다형성 이란,
    - 서로 다른 유형의 객체가 동일한 메시지에 대해 서로 다르게 반응하는 것
    - 서로 다른 타입의 객체들이 동일한 메시지를 수신할 때, 서로 다른 메서드를 이용해 메시지를 처리할 수 있는 매커니즘
    - 하나의 메시지 — 하나 이상의 메서드 사이의 관계

- 다형성을 만족시킨다 == 객체들이 동일한 책임을 공유한다
    ⇒ 전송한 메시지의 수신자가 어떤 종류인지 상관 없음 → **대체 가능성**
    
- 대체 가능성의 의의
    - 설계를 유연하고 협력을 재사용 가능하게 할 수 있다
    - 송신자가 수신자의 종류를 몰라도 메시지를 전송할 수 있다 ⇒ **수신자의 종류를 캡슐화, 유연한 협력 가능**
    - 협력이 수행되는 방식을 쉽게 수정, 확장할 수 있다

- 송신자와 수신자를 약하게 연결하는 메시지
    - 메시지를 통해 수신자—송신자 간의 결합도를 낮춤으로써 설계를 `유연`하고, `확장 가능`하고, `재사용 가능`하게 한다

<br/>

## 메시지를 따라라

- 객체지향 애플리케이션 — 클래스를 이용해 만들어지지만, 메시지를 통해 정의된다.
- 클래스 — 동적인 객체들의 특성과 행위를 정적인 텍스트로 표현하기 위해 사용하는 추상화 도구
- 객체를 독립된 단위가 아닌 협력이라는 문맥 안에서 생각해야 한다.
- 객체가 어떤 메시지를 전송할 수 있는가 / 어떤 객체가 어떤 메시지를 이해할 수 있는가를 중심으로 협력 관계를 구성해야 한다.
- 메시지가 객체를 선택하게 해야 한다.
- 다시 보는 **책임—주도 설계**: 객체 간의 메시지를 기반으로 역할, 책임, 협력을 발견하는 것
    - What/Who 사이클
        - 어떤 행위(what, 메시지)가 필요한지를 먼저 결정한 후에
            
            이 행위(who)를 수행할 객체를 수행하는 것
            
    - 데메테르 법칙 (tell, don’t ask 스타일)
        - 메시지를 먼저 결정하고 객체가 메시지를 따르게 하는 설계 방식
        - 객체를 자율적으로 만들고 캡슐화를 보장하며 결합도를 낮게 유지시켜 줌

<br/>

## 객체 인터페이스

인터페이스

- 특징
    - 인터페이스의 사용법을 익히면 내부 구조/동작 방식을 몰라도 쉽게 대상 조작 및 의사 전달이 가능하다
        - 자동차 내부 구성 몰라도 운전 가능
    - 인터페이스 변경 없이 단순 내부 구성/작동 방식 변경은 사용자에게 어떤 영향도 미치지 않는다
        - 자동차 구성 변해도 운전 방법이 바뀌지 않음
    - 대상이 변경되더라도 동일한 인터페이스를 제공하면 아무 문제 없이 상호작용 가능하다
        - 하나의 자동차 운전에 능숙 → 다른 자동차 운전도 가능

- 인터페이스는 객체가 수신할 수 있는 메시지의 목록으로 구성

- **공용 인터페이스**
    - 외부에 공개된 (접근 가능한) 인터페이스
    - 외부로부터 수신할 수 있는 메시지의 목록

- **구현**
    - 내부 구조와 작동 방식
    - 객체의 상태, 메서드를 구성하는 코드 자체

- 인터페이스 관련 주요 3원칙
    - 좀 더 추상적인 인터페이스
        - 자율성
    - 최소 인터페이스
        - 외부에서 사용할 필요가 없다면 최대한 노출하지 않는다
            
            → 내부를 수정하더라도 외부에 미치는 영향을 최소화
            
    - 인터페이스 — 구현 간의 차이 인식
        - 아래 챕터 보기!

<br/>

## 인터페이스와 구현의 분리

- **`인터페이스와 구현의 분리 원칙`** : 공용 인터페이스와 구현을 명확하게 분리해서 고려해야 함
- 변경될 만한 부분을 내부에 숨겨놓음을 의미 ⇒ `캡슐화`(정보 은닉)
- 공용 인터페이스를 경계로 최대한의 자율성을 보장받음
- 자율적인 객체는 공용 인터페이스를 수정하지 않는 한
    
    협력하는 외부 객체에 영향을 미치지 않고 내부 구현을 자유롭게 수정 가능함
    
<br/>

## 결론: 자율적인 책임 → 협력의 설계 품질을 결정

1. 자율적인 책임은 협력을 단순하게 만든다.
2. 자율적인 책임은 외부와 내부를 명확하게 분리한다.
3. 자율적인 책임은 책임을 수행하는 내부 방법이 변경되어도 외부에 영향을 미치지 않는다.
4. 자율적인 책임은 협력의 대상을 다양하게 선택할 수 있는 유연성을 제공한다.
5. 자율적인 책임을 가질수록 객체의 역할을 이해하기 쉬워진다.

<br/>

느낀 점: 적당히 추상적인 책임은 자율성을 갖고, 자율적인 객체가 중요하다 는 것을 매우 강조하는 듯 하다.

또한 이번 챕터를 통해 인터페이스 이야기가 나왔는데, 인터페이스는 메시지의 목록이라고 했다.
메시지는 수행해야 할, 혹은 요청할 책임이니 
인터페이스는 책임의 목록, 책임의 모임, 즉 **역할**이라고 할 수 있을까?!!!

<br/>

그리고 추가적 의문점

Q. 안드로이드에서는 책임—주도 설계를 어떻게 적용할 수 있을까?