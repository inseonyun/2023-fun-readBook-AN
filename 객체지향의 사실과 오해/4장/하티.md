# 04. 역할, 책임, 협력

## 서론

- 개인이 처해 있는 정황 또는 문맥(context)이 인간의 행동 방식을 결정한다.
- 문맥: 타인과의 협력
- **객체지향**에서도 **문맥이 객체의 행동 방식을 결정**한다.
    
    ⇒ 협력이라는 문맥을 고려하지 않는 채 객체의 상태와 행동부터 고민하는 실수가 빈번하다.
    
- 객체지향의 품질은 개별 객체의 품질이 아니라 여러 객체들이 모여 이뤄내는 **협력의 품질**에 의해 결정된다.
- **개별적인 객체의 행동이나 상태가 아니라 객체들 간의 협력에 집중하라.**

- 객체지향 설계의 품질을 결정하는 역할, 책임, 협력은 무엇인가? → 협력이 어떤 식으로 객체의 외양과 특성을 결정하는가?

## 협력

- 다수의 연쇄적인 요청과 응답의 흐름
- 다른 사람에게 도움을 요청 → 요청받은 사람은 필요한 지식/서비스를 제공함으로써 요청에 응답
- 요청을 받아들인다 → 요청에 대해 적절한 방식으로 응답하는 데 필요한 **지식와 행동 방식**을 가지고 있다.
- 요청과 응답 → 협력에 참여하는 **객체가 수행할 책임**을 의미한다.
    
    e.g.) 왕이 모자 장수에게 재판에서 증언을 요청 → 모자 장수는 사건의 내용에 대해 지식이 있고, 증언할 의무가 있음
    

<aside>
💡 객체를 설계하는 과정에서 협력 관계를 먼저 고려하게 된다면, 각 객체가 갖고 있는 지식과 행동 (프로퍼티와 메소드)는 자연스럽게 결정이 되는 걸까?

</aside>

<br/>

## 책임

- 어떤 대상에 대한 요청 → 그 대상이 **요청을 처리할 책임**이 있다.
- 적절한 객체에게 적절한 책임을 할당해야 한다.
- 또한, 책임을 명확하게 해야 한다.
- 일반적으로 외부에서 접근 가능한 공용 서비스의 관점에서 이야기를 한다.
    
    즉, 책임은 객체의 **공용 인터페이스(public interface)**를 구성한다. ⇒ **`캡슐화`**
    

### 분류

- 객체의 책임은 `Knowing: 무엇을 알고 있는가` 와 `Doing: 무엇을 할 수 있는가` 로 구성된다.
- Knowing: 아는 것     ⇒ **객체의 외부에 제공해 줄 수 있는 정보**
    - 개인적인 정보에 관해 아는 것
    - 관련된 객체에 관해 아는 것
    - 자신이 유도하거나 계산할 수 있는 것에 관해 아는 것
- Doing: 하는 것         ⇒ **외부에 제공해 줄 수 있는 서비스**
    - 객체를 생성하거나 계산하는 등 스스로 하는 것
    - 다른 객체의 행동을 시작시키는 것
    - 다른 객체의 활동을 제어, 조작하는 것
    

### 책임과 메시지

- 메시지 전송(message-send): 객체가 다른 객체에게 주어진 책임을 수행하도록 요청을 보내는 것
    
    송신자: 메시지를 전송함으로써 협력을 요청하는 객체
    
    수신자: 메시지를 받아 요청을 처리하는 객체
    
- 메시지는 협력을 위해 한 객체가 다른 객체로 접근할 수 있는 유일한 방법
- 실제로 협력을 정제하면서 이를 메시지로 변환할 때는 하나의 책임이 여러 메시지로 분할되는 경우가 많다.
- 객체지향 설계는
    
    협력에 참여하기 위해 어떤 객체가 어떤 책임을 수행해야 하고
    
    어떤 객체로부터 메시지를 수신할 것인지를 결정하는 것으로부터 시작된다.
    
## 역할

- `역할`을 사용하면 세 가지 협력을 모두 포괄할 수 있는 하나의 협력으로 추상화할 수 있다.
- 협력 내에서 다른 객체로 대체할 수 있음을 나타내는 일종의 표식
- 물론, 역할을 대체할 수 있는 객체는 동일한 메시지를 이해할 수 있는 객체로 한정된다.
- 동일한 역할을 수행한다 == 협력 내에서 동일한 책임의 집합을 수행할 수 있다
- 객체지향의 **단순성**, **유연성**, **재사용성**을 뒷받침

### 추상화

- 역할의 가장 큰 가치: 하나의 협력 안에 여러 종류의 객체가 참여 → 추상화
- 역할을 이용하면 협력을 추상화함을써 단순화할 수 있다.

### 대체 가능성

- 역할: 협력 안에서 구체적인 객체로 대체될 수 있는 추상적인 협력자
- 역할은 다른 객체에 의해 대체 가능하다.
- 역할을 대체 → 행동이 호환된다 → 협력 안에서 역할이 수행하는 모든 책임을 동일하게 수행할 수 있다.
- 객체—역할 사이에는 **일반화/특수화 관계**가 성립한다.
    - 좀 더 일반적인 개념: 일반화
    - 좀 더 구체적인 개념: 특수화
- **역할의 대체 가능성: 행위 호환성,  행위 호환성: 동일한 책임의 수행**

## 객체의 모양을 결정하는 협력

- 객체가 존재하는 이유: 데이터를 저장하기 위함 < 행위를 수행하며 협력에 참여하기 위함
    
    → 행동, 책임이 중요하다.
    
- 클래스—클래스 간의 정적인 관계 < 협력에 참여하는 동적인 객체
- 클래스를 어떻게 구현할 것인가 < 객체가 협력 안에서 어떤 책임와 역할을 수행할 것인가
- 협력이라는 견고한 문맥이 갖춰지면 협력을 위해 필요한 책임의 흐름을 고려
- 책임은 협력의 문맥 안에서 분배되어야 함
- 충분히 자율적이면서 협력적인 객체를 창조하는 것!

## 객체지향 설계 기법

### 책임—주도 설계 (Responsibility—Driven Design)

- 협력에 필요한 책임들을 식별하고 적합한 객체에게 책임을 할당하는 방식
- 핵심은 올바른 책임을 올바른 객체에게 할당하는 것
- 시스템의 기능은 더 작은 규모의 책임으로 분할되고 각 책임은 책임을 수행할 적절한 객체에게 할당됨
- 시스템의 책임을 객체의 책임으로 변환하고, 협력자를 찾아 책임을 할당하는 순차적인 방식으로 협력 공동체를 구축
- 개별적인 객체의 상태가 아니라 객체의 책임과 상호작용에 집중

### 디자인 패턴 (Design Pattern)

- 전문가들이 반복적으로 사용하는 해결 방법을 정의해 놓은 설계 템플릿의 모음
- 이미 식별해 놓은 역할, 책임, 협력의 모음
- 패턴은 특정한 상황에서 어떤 설계가 왜 더 효과적인지에 대한 이유를 설명한다.
- e.g. COMPOSITE pattern
- 책임—주도 설계의 결과물인 동시에 지름길

### 테스트—주도 개발 (Test—Driven Development)

- 테스트를 먼저 작성하고 테스트를 통과하는 구체적인 코드를 추가하면서 애플리케이션을 완성해가는 방식
- 테스트가 아니라 설계를 위한 기법!
- 실패하는 테스트 작성 → 테스트를 통과하는 가장 간단한 코드 작성 → 리팩터링
- 객체가 이미 존재한다고 가정하고, 객체에게 어떤 메시지를 전송할 것인지에 관해 먼저 생각해보기
(물론 역할, 책임, 협력의 관점에서 객체를 바라본다는 가정 하에)
- 책임—주도 설계를 통해 도달해야 하는 목적지를 테스트를 통해 빠르고 견고하게 도달하도록 해준다.
