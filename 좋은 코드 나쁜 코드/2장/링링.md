# 추상화 계층

## 2장 목표

- 깔끔한 추상화 계층을 통해 문제를 하위 문제로 세분화하는 방법
- 추상화 계층이 코드 품질의 요소를 달성하는 데 어떻게 도움이 되는지
- API 및 구현 세부 사항
- 함수, 클래스 및 인터페이스를 사용해 코드를 추상화 계층으로 나누는 방법

</br>

## 왜 추상화 계층을 만드는가?

어떤 문제를 하위 문제로 계속해서 나누어 내려가면서 추상화 계층을 만든다면, 같은 층위 내에서는 쉽게 이해할 수 있는 몇 개의 개념만을 다루기 때문에 개별 코드는 특별히 복잡해 보이지 않을 것이다. 소프트웨어 엔지니어로서 문제를 해결할 때 이것이 목표가 되어야 한다. 비록 문제가 엄청나게 복잡할지라도 하위 문제들을 식별하고 올바른 추상화 계층을 만듦으로써 그 복잡한 문제를 쉽게 다룰 수 있다. 

### 추상화 계층 및 코드 품질의 핵심 요소

**가독성**

코드의 모든 세부 사항을 이해하는 것은 불가능하지만 몇 가지 높은 계층의 추상화를 이해하고 사용하기는 쉽다. 따라서 코드의 가독성이 향상된다.

**모듈화**

모듈화가 잘 되어야, 다른 계층이나 코드의 일부에 영향을 미치지 않고 계층 내에서만 구현을 변경하기가 매우 쉬워진다. 

**재사용성 및 일반화성**

하위 문제에 대한 해결책이 간결한 추상화 계층으로 제시되면 해당 하위 문제에 대한 해결책을 제사용하기 쉬워진다. 그리고 문제가 적절하게 추상적인 하위 문제로 세분화된다면, 해결책은 여러가지 다른 상황에서 유용하게 일반화될 가능성이 크다. 

**테스트 용이성**

신뢰할 수 있는 코드를 작성하고자 한다면, 각 하위 문제에 대한 해결책이 견고하고 제대로 작동하는지 확인해야 한다.                                                                                                                                                                               

</br>

## 코드의 계층

### API 및 구현 세부 사항

코드를 작성할 때 고려해야 할 측면이 두 가지 있다. 

- 코드를 호출할 때 볼 수 있는 내용
- 코드를 호출할 때 볼 수 없는 내용

</br>

### 함수

- 단일 업무 수행
- 잘 명명된 다른 함수를 호출해서 더 복잡한 동작 구성

</br>

### 클래스

**응집력**

좋은 클래스는 매우 응집력이 강하다. 

- 순차적 응집력 : 한 요소의 출력이 다른 요소에 대한 입력으로 필요할 때 발생
- 기능적 응집력 : 몇 가지 요소들이 모여서 하나의 일을 성취하는데 기여할 때 발생

**관심사의 분리**

시스템이 각각 별겨의 문제(또는 관심사)를 다루는 개별 구성 요소로 분리되어야 한다고 주장하는 설계 원칙이다.

클래스가 분리되어야 할지 판단하기 위해서는 이 클래스가 어떻게 네 가지 핵심 요소에 반하여 작성되어 있는지 살펴보는 것이 더 나을 수도 있다.

코드 내부에 하위 문제에 대한 해결책을 자체 클래스로 분할하여 개선할 수 있으며, 하위 문제를 해결하기 위한 클래스는 생성자의 매개변수를 통해 클래스에 제공할 수 있다. 이 패턴을 우리가 의존성 주입 (DI : Dependency Injection)이라고 부른다. → 8장

</br>

### 인터페이스

주어진 추상화 계층에 대한 한 가지 구현만 있고 향후에 다른 구현을 추가할 계획이 없더라고 여전히 인터페이스를 통해 추상화 계층을 표현해야 하는가?

구현이 단 하나 뿐이더라도 인터페이스를 구현하는 접근 방식에는 어떤 장점/단점이 존재할까?

**장점**

- 퍼블릭 API를 매우 명확하게 보여준다.
- 한 가지 구현만 필요하다고 잘못 추측한 것일 수 있다.
- 테스트를 쉽게 할 수 있다.
- 같은 클래스로 두 가지 하위 문제를 해결할 수 있다.

**단점**

- 더 많은 작업이 필요하다.
- 코드가 복잡해 질 수 있다.

모든 클래스에 인터페이스를 붙이는 극단적이 입장의 코드는 종종 통제가 불가능하고, 불필요하게 복잡하며, 이해와 수정이 어렵다.

</br>

### 층이 너무 얇아질 때

코드를 별개의 계층으로 세분화하면 장점이 많지만 다음과 같은 추가 비용이 발생한다.

- 클래스를 정의하거나 의존성을 새 파일로 임포트하려고 반복적으로 사용하는 코드로 인해 코드의 양이 늘어난다.
- 로직의 이해를 위해 파일이나 클래스를 따라갈 때 더 많은 노력이 필요하다
- 인터페이스 뒤에 계층을 숨기게 되면 어떤 상황에서 어떤 구현이 사용되는지 파악하는 데 더 많은 노력이 필요하다. 이로 인해 로직을 이해하거나 디버깅하는 것이 더 어려워질 수 있다.

</br>

## 마이크로 서비스는 어떤가?

마이크로서비스 아키텍처에서는 개별 문제에 대한 해결책이 단지 단일 프로그램으로 컴파일되는 라이브러리 수준이 아니라 독립적으로 실행되는 서비스로 배포된다. 
즉, 시스템이 여러 개의 소규모 프로그램으로 분할되어 특정 작업만 전문적으로 수행한다. 
이런 소규모  프로그램은 API를 통해 원격으로 호출할 수 있는 전용 서비스로 배포된다. 
마이크로서비스는 여러 가지 이점을 가지고 있으며 최근 몇 년간 점점 더 인기를 끌고 있다. 
마이크로서비스는 시스템을 분리하여 보다 모듈화할 수 있는 매우 좋은 방법이지만, 서비스를 구현하기 위해 여러 하위 문제를 해결해야한다는 사실은 바뀌지 않는다.
