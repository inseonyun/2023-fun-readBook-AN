# 2장) 추상화 계층

### 의존성 주입

이 클래스가 의존하는 클래스의 인스턴스가 주입되는 것을 말함.

의존성 주입을 활용하면, 높은 수준의 추상화 구조를 만들어서, 이 클래스를 사용하는 개발자가 사용하기 쉽게 만들 수 있다고 함.

이렇게 클래스 구조를 추상화시키고, 각 클래스의 역할을 작게 줄이다보면 인터페이스로 만들기도 쉬워지고, 이런 인터페이스 구조를 사용하면 나중에 기능 중 일부를 대체하기도 쉽다.

이 외에도 여러 장점들이 있다.

- 다른 곳에서 해당 인터페이스를 구현한 구현체나 이미 있는 구현체를 재사용 가능하다
- 자연스럽게 퍼블릭으로 공개될 것이므로 테스트하기가 쉽다.

### 인터페이스를 어디까지 만들것인가?

인터페이스는 좋은 추상화 계층을 만드는 훌륭한 도구다.

하지만, 향후에도 다른 구현이 추가될 것 같지 않은 경우에도 인터페이스를 두어야 할까?

이것은 팀끼리 결정할 사안이지만,

몇몇 소프트웨어 공학론에서는 여전히 인터페이스를 사용할 것을 권고한다고 함.

이렇게 했을 때 장점은 아래와 같다고.

- 퍼블릭 메소드를 명확히 파악 가능
- 만약 나중에 갑자기 새로운 구현체가 필요할 때 대응이 쉽다
- 테스트가 쉽다
    - 구현 클래스가 좀 복잡하거나, 네트워크 통신 작업이 필요하다면 테스트를 위해 인터페이스를 선언해야할 필요가 있을 수 있다.
- 그때그때 목적에 따라 여러 문제 해결을 위해 사용될 수 있다
    - 링크드리스트 구현체가, 때로는 리스트로 때로는 큐로 사용될 수 있다. 왜? 두 가지 인터페이스를 모두 구현한 구현체이므로

단점은 아래와 같다고 한다.

- 인터페이스 파일을 만들어야 해서 시간이 더 걸린다
- 코드가 복잡해져서 파악하기 힘들어진다.
    - IDE 상에서 하위 클래스로 바로 이동하는게 아니라 인터페이스를 거쳐서 이동해야 하므로.

필자의 경험 → 모든 클래스에 인터페이스를 붙이는 것은 미친짓이다. 이해도 수정도 어렵다. 단, 필요할 때 인터페이스를 적용해도 코드가 영향 받지 않더라도 평소 클래스의 메소드들 중 어떤 것들을 퍼블릭으로 열지 잘 정의해야 한다.

# 코드를 계층으로 구분할 때 기준

코드 계층의 규모를 올바르게 정하는 것은 중요한데, 의미있는 추상화 계층 구조를 만들어야 한다.

계층으로 나눠도, 너무 크게 나누면 모듈화가 잘 되지 않은 것이고,

너무 작게 나눠버리면, 불필요하게 둘로 계층을 분리한 것이 된다.

하지만, 둘 중 무엇이 더 나은지 고민을 만나게 된다면 많은 계층을 남용하더라도 그냥 분리시켜서 작게 나눠라. 일반적으로 계층을 크게 나눈 것보다는 나중에 문제를 덜 불러일으킨다고.

# 마이크로서비스 같은 소규모 프로그램은?

똑같다. 시스템을 분리해서 모듈화하는 방법일 뿐, 그 안에서도 나눠진 해당 서비스를 구현하기 위해 좋은 추상화 구조를 만들어야 하는 것에는 변함이 없다.
