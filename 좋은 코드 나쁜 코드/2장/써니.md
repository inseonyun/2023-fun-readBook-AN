# 추상화 계층

코드 작성 목적은 문제 해결이다. 
코드를 구성하는 방법은 코드 품질의 기본적인 측면 중 하나이며, 코드를 잘 구성한다는 것은 간결한 **추상화 계층**을 만드는 것으로 귀결될 때가 많다.

## 2.1 널값 및 의사코드 규약
널(null)값ㅇ은 참조/포인터가 없다는 개념을 갖고 있다.
널값은 믿을 수 없을 정도로 유용하면서 동시에 믿을 수 없을 정도로 문제가 많은 양극단의 역사를 갖고 있다.

널 안전성과 보이드 안전성
널 안전성을 가질 수 있는 언어(kotlin 등등등...)에서 '?' 기호가 붙어 있으면 널 값을 가질 수 있고, 이 때, 널값  여부를 확인하지 않고서는 사용할 수 없도록 컴파일러가 강제한다.

## 2.2 왜 추상화 계층을 만드는가?
코드 작성은 복잡한 문제를 계속해서 더 작은 하위 문제로 세분화하는 작업이다.
간결한 추상화 계층은 다른 사람이 하위 문제 해결책을 재사용, 정의 할 수 있기 때문에 상위 문제를 해결하기 위해 몇 가지 개념만 알면 된다.

### 2.2.1 추상화 계층 및 코드 품질의 핵심 요소
**가독성**
개발자들이 코드베이스에 있는 코드의 모든 세부 사항을 이해하는 것은 불가능하지만 몇 가지 높은 계층의 추상화를 이해하고 사용하기는 상당히 쉽다. 
-> 깨끗하고 뚜렷한 추상화 계층을 만드는 것은 개발자가 한 번에 한두 개 정도의 계층과 몇 개의 개념만 다루면 된다는 것을 의미

**모듈화**
추상화 계층이 하위 문제에 대한 해결책을 깔끔하게 나누고 구현 세부 사항이 외부로 노출되지 않도록 보장할 때, 다른 계층이나 코드의 일부에 영향을 미치지 않고 계층 내에서만 구현을 변경하기 매우 쉬워진다.

**재사용성 및 일반화성**
하위 문제에 대한 해결책이 간결한 추상화 계층으로 제시되면 해당 하위 문제에 대한 해결책을 재사용하기가 쉬워진다. 그리고 문제가 적절하게 추상적인 하위 문제로 세분화된다면, 해결책은 여러 가지 다른 상황에서 유용하게 일반화될 가능성이 크다.

**테스트 용이성**
신뢰할 수 있는 코드를 작성하려면 각 하위 문제에 대한 해결책이 견고하고 제대로 작동하는지 확인해야 한다. 코드가 추상화 계층으로 깨끗하게 분활되면 각 하위 문제에 대한 해결책을 완벽하게 테스트하는 것이 훨씬 쉬워진다.

## 2.3 코드의 계층
추상화 계층을 생성하는 방법은 코드를 서로 다른 단위로 분할하여 단위 간의 의존 관계를 보여주는 의존성 그래프를 생성하는 것이다.
코드를 다른 단위로 나누기 위해 사용하는 언어 요소들
+ 함수
+ 클래스(및 구조체나 믹스인과 같이 클래스와 비슷한 요소들도 포함)
+ 인터페이스(또는 이와 동일한 요소)
+ 패키지, 네임스페이스, 모듈

### 2.3.1 API 및 구현 세부 사항
코드를 작성할 때 고려해야할 측면 두 가지
+ 코드를 호출할 때 볼 수 있는 내용
    + 퍼블릭 클래스, 인터페이스 및 함수
    + 이름, 입력 매개변수 및 반환 유형이 표현하고자 하는 개념
    + 코드 호출 시 코드를 올바르게 사용하기 위해 알아야하는 추가 정보(호출 순서)
+ 코드를 호출할 때 볼 수 없는 내용: 구현 세부사항

API(Application Programming Interface)는 서비스를 사용할 때 알아야 할 것들에 대한 개념을 형식화하고, 서비스의 모든 구현 세부 사항은 이 API 뒤에 감춘다.
API는 호출하는 쪽에 공개할 개념만 정의하면 되고 그 이외의 모든 것은 구현 세부 사항이기 때문에 코드를 API의 관점에서 생각하면 추상확 ㅖ층을 명확하게 만드는 데 도움이 된다.
--> 코드의 일부를 작성하거나 수정할 때, API에 이 수정 사항에 대한 구현 세부 정보가 새어 나간다면 추상화 계층이 명확하게 구분되어 이뤄진 것이 아니다.

### 2.3.2 함수
함수에 포함된 코드가 하나의 잘 써진 짧은 문장처럼 읽히면 이상적인 함수다.
+ 하나의 일만 수행해야 한다.
+ 잘 명명된 다른 함수를 호출해서 더 복잡한 동작을 구성한다.
> 함수를 작성했다면 작성된 코드를 문장으로 만들어보면 좋다. 문장을 만들기 어렵거나 너무 어색하면 함수가 너무 길다는 것을 의미하고 더 작은 함수로 나누는 것이 유익하다.

함수를 작게 만들고 수행하는 작업을 명확하게 하면 코드의 가독성과 재사용성이 높아진다. 

### 2.3.3 클래스
+ 줄 수(Number of lines): 때때로 한 클래스는 코드 300줄을 넘지 않아야 한다와 같은 가이드 라인을 접하는 경우가 있다.
    > 300줄보다 긴 클래스는 너무 많은 개념을 다루므로 분리해야 한다는 것이다. 물론 꼭 300줄 이하라는 제한이 옳지 않을 수 있다.
+ 응집력(cohesion): 한 클래스 내의 모든 요소들이 얼마나 잘 속해 있는지를 보여주는 척도로, 좋은 클래스는 매우 응집력이 강하다. 
    + 순차적 응집력: 한 요소의 출력이 다른 요소에 대한 입력으로 필요할 때 발생 
        > EX 커피 한 잔을 만들 때, 원두를 갈기 전에는 커피 추출이 불가능하며, 원두를 갈아낸 후의 산출물이 커피를 추출하는 과정에 투입된다.
    + 기능적 응집력: 몇 가지 요소들이 모여 하나의 일을 성취하는 데 기여할 때 발생한다.
        > Ex 케이크를 만들기 위해 필요한 모든 장비를 준비해야 한다.
+ 관심사 분리(Separation of concerns): 이것은 시스템이 각각 별개의 문제를 다루는 개별 구성 요소로 분리되어야 한다고 주장하는 설계 원칙이다.
    > 어떤 물건이든 함수든 클래스든 각각의 정의된 기능을 연관된 기능에 방해 없이 수행한다.

**코드 개선 방법**
하위 문제에 대한 해결책을 자체 클래스로 분할하여 개선할 수 있으며 하위 문제를 해결하기 위한 클래스는 생성자의 매개변수를 통해 클래스에 제공된다. 이 패턴은 **의존성 주입(Dependency Injection)**이라 한다.

### 2.3.4 인터페이스
계층 사이를 뚜렷이 구분하고 구현 세부 사항이 계층 사이에 유출되지 않도록 하기 위해 사용할 수 있는 한 가지 접근법은 어떤 함수를 외부로 노출할 것인지를 인터페이스를 통해 결정하는 것이다.
이 때, 이보다 위에 있는 계층은 인터페이스에 의존할 뿐 로직을 구현하는 구체적인 클래스에 의존하지 않는다.

**모든 것을 위한 인터페이스**
주어진 추상화 계층에 대해 한 가지 구현만 있고 향후에 다른 구현을 추가할 계획이 없더라도 여전히 인터페이스를 통해 추상화 계층을 표현해야 하는가는 여러분과 여러분의 팀이 결정할 사안이다.
> ㅋㅋㅋㅋ재밌넹...

### 2.3.5 층이 너무 얇아질 때
코드를 별개의 계층으로 세분화하면 장점이 많지만 다음과 같은 추가 비용이 발생한다.
+ 클래스를 정의하거나 의존성을 새 파일로 임포트하려고 반복적으로 사용하는 코드로 인해 코드의 양이 늘어난다.
+ 로직의 이해를 위해 파일이나 클래스를 따라갈 때 더 많은 노력이 필요하다.
+ 인터페이스 뒤에 계층을 숨기게 되면 어떤 상황에서 어떤 구현이 사용되는지 파악하는 데 더 많은 노력이 필요하다. 이로인해 로직을 이해하거나 디버깅하는 것이 더 어려워질 수 있다.


## 2.4 마이크로서비스
-> 뭔 소리?

## 요약
+ 코드를 깨끗하고 뚜렷한 추상화 계층으로 세분화하면 가독성, 모듈화, 재사용, 일반화 및 테스트 용이성이 향상된다.
+ 특정 언어에 국한된 기능뿐만 아니라 함수, 클래스 및 인터페이스를 사용하여 코드를 추상화 계층으로 나눌 수 있다.
+ 코드를 추상화 계층으로 분류하는 방법을 결정하려면 해결 중인 문제에 대한 판단과 지식을 사용해야 한다.
+ 너무 비대한 계층 때문에 발생하는 문제는 너무 얇은 계층 때문에 발생하는 문제보다 더 심각하다. 확실하지 않는 경우에는 남용의 위험에도 불구하고 계층을 얇게 만드는 것이 좋다.


