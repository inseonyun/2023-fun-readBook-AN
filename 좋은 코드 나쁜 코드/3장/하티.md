# 03. 다른 개발자와 코드 계약

- 소프트웨어 작성, 유지보수를 팀 단위로 수행
    
    → 내가 작성한 코드를 다른 개발자가 작업하고, 다른 개발자가 작업한 코드를 내가 작업해야 함
    

## 1. 자신의 코드와 다른 개발자의 코드

- 다른 개발자들이 활발하게 코드를 변경하더라도 코드의 품질을 유지하기 위해 고품질 코드를 작성해야 한다.
    - 튼튼하고, 사용하기 쉬운 코드
    - 코드를 변경하거나 상호작용할 때 발생하는 문제가 없는지, 있다면 어떻게 문제를 완화할 수 있을지에 대한 선제 조치

### 코드 작성 시 고려할 사항

- 자신에게 분명하다고 해서 다른 사람에게도 분명한 것은 아니다.
    - 주석 없이도 코드 자체로 설명이 되게 하는 것이 좋다.
- 다른 개발자는 무의식중에 여러분의 코드를 망가뜨릴 수 있다.
    - 이를 방지할 수 있는 신뢰할만 한 방법: 문제 발생 시 코드 컴파일을 중지시키거나, 테스트가 실패하거나.
- 시간이 지남에 따라 자신이 작성한 코드를 기억하지 못한다.
    - 자신이 작성한 코드도 잊을 가능성이 높으므로, 미래의 나 자신도 다른 개발자로 간주하자.

## 2. 여러분이 작성한 코드의 사용법을 다른 사람들은 어떻게 아는가?

- 다른 개발자가 나의 코드를 사용하거나 나의 코드에 의존하는 코드를 수정할 때, 파악해야 할 사항들
    - 여러 가지 상황에서 어떤 함수를 호출해야 하는지
    - 클래스가 무엇을 나타내는지, 언제 사용되어야 하는지
    - 어떤 값을 인수로 사용해야 하는지
    - 코드가 수행하는 동작이 무엇인지
    - 어떤 값을 반환하는지
- 이를 위해 다른 개발자가 할 수 있는 일
    - 함수, 클래스, 열거형 등의 이름을 살핀다.
        - 실제로 많이 사용하는 주된 방법
        - 이 이름은 마치 책의 목차와 같은 역할을 한다.
    - 함수와 생성자의 매개변수 유형, 반환값의 유형 등 데이터 유형을 살핀다.
    - 함수/클래스 수준의 문서나 주석문을 읽어본다.
        - 문서 형태
            - 비공식적인 주석문
            - 공식적인 코드 내 문서 (e.g. JavaDoc)
            - 외부 문서 (e.g. README.md, 웹 페이지)
        - 한계
            - 다른 개발자가 이 문서들을 읽는다는 보장이 없고, 실제로 읽지 않는 경우 多
            - 읽었을 때 잘못 해석할 가능성 존재
            - 문서의 업데이트가 잘 이루어지지 않을 가능성 존재
    - 직접 혹은 채팅, 이메일을 통해 물어본다.
        - 한계
            - 질문에 답하는 데 너무 많은 시간 소모
            - 작성자가 휴가가면? 작성자가 코드 이제 기억 못하면? 작성자가 회사를 떠났다면?
    - 함수와 클래스의 자세한 구현 코드를 읽는다.

## 3. 코드 계약

- 계약에 의한 프로그래밍, 계약에 의한 디자인
- 다른 사람들이 어떻게 코드를 사용할지, 코드가 무엇을 할 것으로 기대할 수 있는지

### 코드 계약 관련 용어

- 선결 조건 precondition
    - 코드를 호출하기 전에 사실이어야 하는 것
    - e.g. 시스템이 어떤 상태에 있어야 하는지
- 사후 조건 postcondition
    - 코드가 호출된 후에 사실이어야 하는 것
    - e.g. 반환되는 값
- 불변 사항 invariant
    - 코드가 호출되기 전후로 시스템 상태에서 변경되지 않아야 하는 것

### 계약의 세부 조항

- 계약의 명확한 부분
    - 함수와 클래스 이름
    - 인자 유형
    - 반환 유형
    - 검사 예외: 호출하는 코드가 이것을 처리하지 않으면 코드는 컴파일되지 않는다.
- 계약의 세부 조항
    - 주석문과 문서
    - 비검사 예외 (일반적인 예외)
- 조건을 명백하게 하는 것이 중요함
- 세부 조항에 너무 의존하면 좋지 않다.
    - 세부 조항을 제거하려면?
    - 세부 조항에 있는 항목에 대한 발생 자체가 불가능하도록 하여 명백해지도록 변경한다.
- 코드에 숨겨진 세부 조항이 많을수록 오류 발생 가능성이 높아진다.

## 4. 체크 및 어서션

### 체크

- 코드 계약 조건을 확인하는 일반적인 방법
- 코드 계약이 준수되었는지를 확인하기 위한 추가적인 로직
- 준수도지 않을 경우 체크는 실패를 유발하는 명백한 오류를 생성 (→ 신속한 실패)
- e.g. 스쿠터의 펌웨어에 안전장치를 추가한다.

계약 조건에 따른 구분

- 전제 조건 검사
    - e.g. 입력 인수가 올바른지, 초기화가 수행되었는지, 코드 실행 전 시스템이 유효한 상태인지 확인
- 사후 상태 검사
    - e.g. 반환값이 올바른지, 코드 실행 후 시스템이 유효한 상태인지 확인

한계: 체크의 효과가 항상 보장되지는 않는다.

- 테스트가 불분명한 상황에서만 조건이 위반된다면, 배포되기 전까지 버그가 노출되지 않을 수 있다.
- 체크가 잘 작동해서 명백한 실패임에도 아무도 모를 위험이 있다.

→ 처음부터 세부 조항을 피하는 것이 바람직. 코드에 체크가 많다면 세부 조항을 없애는 걸 고려해보아야 할 듯..

### 어서션 assertion

- 코드 계약을 준수하도록 강제하기 위한 방법
- 코드가 개발 모드에서 컴파일 되거나 테스트가 실행될 때 동작
- 조건이 위반되면 명백하게 오류가 보이거나 예외가 발생
- 체크와의 차이점
    - 배포를 위해 빌드할 때 어서션은 컴파일에서 제외된다.
    - 실제 서비스 환경에서 사용될 때 실패를 명백하게 보여주지 않음을 의미
        - 성능 향상을 위해
            - 조건 위반을 확인하기 위해 CPU 사이클이 필요함 → 성능 저하
        - 코드 오류 발생률을 낮추기 위해
            - 버그가 눈에 띄지 않을 가능성은 증가하나,
            - 버그 발생 가능성 방지보다 고가용성이 더 중요한 시스템이라면?