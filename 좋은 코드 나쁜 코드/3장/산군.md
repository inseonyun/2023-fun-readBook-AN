## CHAPTER 3. 다른 개발자와 코드 계약
### 학습 목표
- 다른 개발자들이 코드와 어떻게 상호작용하는지
- 코드 계약과 코드 계약의 세부 조항
- 세부 조항을 최소화하는 것이 어떻게 오용과 예측을 벗어나는 코드를 예방하는 데 도움이 되는지
- 세부 조항을 피할 수 없다면 체크와 어서션을 어떻게 사용할 수 있는가?

### 3.1 자신의 코드와 다른 개발자의 코드
팀의 일원으로 코드를 작성한다면, 우리는 항상 다른 개발자들의 코드와 마주하게 된다. 그렇기에 다음 세 가지를 고려하는 것이 유용하다.

- 자신에게 명백하다고 해서 다른 사람에게도 명백한 것은 아니다.
- 다른 개발자는 무의식중에 여러분의 코드를 망가뜨릴 수 있다.
- 시간이 지남에 따라 자신의 코드를 기억하지 못한다.

#### 3.1.1 자신에게 명백하다고 해서 다른 사람에게도 명백한 것은 아니다
다른 사람은 내가 코드 설계 및 작성에 대한 리소스를 고려하지 않는다.  
그렇기에 우리는 더욱 더 친절하게 코드를 통해 코드를 가이드 해주어야한다.

#### 3.1.2 다른 개발자는 무의식중에 여러분의 코드를 망가뜨릴 수 있다
우리 코드는 독립적이지 않으며, 여러 가지 다른 코드에 의존하게 된다.  
그 반대도 마찬가지이다.  
내 코드가 망가지는 것을 방어하기 위한 수단으로  
1. 컴파일이 중지되도록 만들기
2. 테스트가 실패하도록 만들기

다음 중 하나가 일어나도록 하는 것이 고품질 코드의 작성과 관련된 많은 고려 사항들이 궁극적으로 이루고자 하는 것이다.  

#### 3.1.3 시간이 지나면 자신의 코드를 기억하지 못한다
제곧내

### 3.2 여러분이 작성한 코드의 사용법을 다른 사람들은 어떻게 아는가?
다른 사람들이 내 코드를 사용할 때, 그들은 다음과 같은 사항들을 이해해야 한다.
- 여러 가지 상황에서 어떤 함수를 호출해야 하는지
- 클래스가 무엇을 나타내는지 그리고 언제 사용되어야 하는지
- 어떤 값을 인수로 사용해야 하는지
- 코드가 수행하는 동작이 무엇인지
- 어떤 값을 반환하는지

1년 뒤의 나 또한 다른 개발자와 다를게 없다!  
1년전에 작성한 코드, 혹은 다른 개발자가 작성한 코드를 어떻게 사용해야 하는지 알아내기 위해 다른 개발자가 할 수 있는 일은 다음과 같다.
- 함수, 클래스, 열거형 등의 이름을 살펴본다.
- 함수와 생성자의 매개변수 유형 또는 반환값의 유형 같은 데이터 유형을 살펴본다.
- 함수/클래스 수준의 문서나 주석문을 읽어본다.
- 직접 와서 묻거나 채팅/이메일을 통해 문의한다.
- 여러분이 작성한 함수와 클래스의 자세한 구현 코드를 읽는다.

#### 3.2.1 이름 확인
책의 목차를 확인하는 것과 같다.  
내가 사용하고자 하는 코드를 찾기 위한 편리하고 빠른 방법이다.

#### 3.2.2 데이터 유형 확인
정적 유형의 언어에서는 데이터 유형을 인식하고 올바르게 사용해야한다.  
유형 시스템을 사용하는 언어로 코드를 작성하는 것은 다른 개발자가 코드를 오용 및 오작동할 수 없도록 하기 위한 좋은 방법 중 하나이다.

#### 3.2.3 문서 읽기
- 주석문
- Doc 등을 이용한 코드 내 문서
- README와 같은 외부 문서

이와 같은 것들을 활용하면 좋지만 다음을 유의하자.
- 다른 개발자가 해당 문서를 읽는다는 보장은 없다.
- 잘못 해석될 수도 있다.
- 문서의 업데이트가 최신화되지 않을 수 있다.

#### 3.2.4 직접 물어보기
- 코드 작성자가 휴가를 간다면?
- 코드 작성자가 1년 전에 쓴 코드라 기억이 나지 않는다면?
- 코드 작성자가 회사에 없다면?
- 불필요한 리소스 낭비가 심하다.

#### 코드를 살펴보는 것
가장 확실한 답을 얻을 수 있는 방법이지만, 코드의 양이 비대할 경우 비효율적이다.

### 3.3 코드계약
앞서 말한 문제점들을 해결하기 위한 원칙이다.  
코드 계약에 대한 용어를 다음과 같은 세 가지 범주로 나눌 수 있다.
- 선결 조건(precondition): 코드를 호출하기 전에 사실이어야 하는 것, 예를 들어 시스템이 어떤 상태에 있어야 하는지, 코드에 어떤 입력을 공급해야 하는지와 같은 사항
- 사후 조건(postcondition): 코드가 호출된 후에 사실이어야 하는 것, 예를 들어 시스템이 새로운 상태에 놓인다든지 반환되는 값과 같은 사항
- 불변 사항(invariant): 코드가 호출되기 전과 후에 시스템 상태를 비교해서 변경되지 않아야 하는 사항

함수의 매개변수나 클래스의 생성자처럼 우리는 알게 모르게 계약을 맺어왔다.

#### 3.3.1 계약의 세부 조항
계약의 명확한 부분(바로 파악할 수 있는 것)
- 함수와 클래스 이름
- 인자 유형
- 반환 유형
- 검사 예외

세부 조항(대부분의 사람이 미처 생각하지 못한 부분)
- 주석문과 문서
- 비검사 예외

세부 조항은 무심코 지나치는 경우가 많다는걸 유의하자.

#### 3.3.2 세부 조항에 너무 의존하지 말라
- 주석에 너무 기대지 말자
- 세부 조항은 안정성이 떨어지기에 코드 설계는 세부 조항에 의존하는 것 보다 잘못된 일을 발생 자체가 불가능하도록 만드는 것이 좋다.

### 3.4 체크 및 어서션
컴파일 타임 체크가 불가능 할때는 런타임 체크를 이용하자

#### 3.4.1 체크
코드 계약 조건을 확인하기 위한 일반적인 방법은 체크를 사용하는 것이다.  
체크는 시행 중인 계약 조건에 따라 다음과 같다.  
- 전제 조건 검사: 예를 들어 입력 인수가 올바르거나, 초기화가 수행되었거나, 일부 코드를 실행하기 전에 시스템이 유효한 상태인지 확인하는 경우
- 사후 상태 검사: 예를 들어 반환값이 올바르거나 일부 코드를 실행한 후 시스템이 유효한 상태인지 확인하는 경우

체크를 사용할 때 기대하는 것은 실제 배포전에 개발 단계나 테스트 단계에서 발견 가능하다.
- 테스트가 진행되지 않는다면 이 방법 또한 보장되지 않는다.
- 실패가 명백하더라도 로그만 남긴 채 서비스가 배포될 가능성이 있다.

경우에 따라 세부 조항을 피할 수 없고, 추가적인 체크가 좋다.

다수의 임시 입력값을 생성해 테스트를 수행하는 '퍼즈 테스트'를 사용하는 경우, 체크를 함께 사용하면 많은 도움이 된다.

#### 3.4.2 어서션
어서션은 코드 계약을 준수하도록 강제하기 위한 방법이라는 점에서 체크와 매우 유사하다.  
어서션과 체크의 차이점은 배포를 위해 빌드할 때 어서션은 보통 컴파일에서 제외된다는 점이다.  
코드를 배포할 때 컴파일하지 않는 이유는 다음과 같다.
- 성능 향상을 위해: 조건이 위반되는지 확인하려면 CPU 사이클이 필요하다. 어서션이 많으면 소프트웨어의 성능이 크게 감소한다.
- 코드 오류 발생률을 낮추기 위해: 이것이 유효한 동기인지 아닌지는 특정 응용 프로그램에 달려 있다. 이로 인해 버그가 눈에 띄지 않을 가능성이 증가하지만 버그 발생 가능성 방지보다 고가용성이 더 중요한 시스템이라면 배포 시에 컴파일에서 제외하는 것은 적절한 절충이 될 수 있다.

물론 코드의 배포를 위한 빌드에서도 어서션을 사용할 수 있는 방법은 많다. 이 경우 체크와 다르지 않고 일부 세부 사항이 조금 다를뿐이다.

결론적으로, 체크와 어서션 모두 코드 계약에 세부 조항이 있을 때 사용하면 좋다.  

### 요약
- 코드베이스는 계속 변한다.
- 다른 개발자가 내 코드를 어떻게 해석할 지 고려해보고, 오용 가능성을 최소화하자.
- 코드를 작성할 때 일종의 코드 계약은 항상 수반된다.
- 코드 계약의 세부 조항은 가능한 피하는것이 바람직하다.
- 일반적으로 컴파일러를 사용해 계약을 확인하는 것이 가장 신뢰할만한 방법이다.
  - 이것이 불가능할 때, 체크나 어서션을 사용해 런타임에 계약을 확인할 수 있다.
