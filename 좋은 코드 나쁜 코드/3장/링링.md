# 다른 개발자와 코드 계약

## 3장 목표

- 다른 개발자들이 코드와 어떻게 상호작용하는지
- 코드 계약과 코드 계약의 세부 조항
- 세부 조항을 최소화하는 것이 어떻게 오용과 예측을 벗어나는 코드를 예방하는 데 도움이 되는지
- 세부 조항을 피할 수 없다면 체크와 어서션을 어떻게 사용할 수 있는가?

## 자신의 코드와 다른 개발자의 코드

고품질 코드를 작성할 때 가장 중요한 고려 사항 중 하나는 다른 개발자가 변경하거나 코드와 상호작용할 때 발생할 수 있는 문제는 없는지, 또 발생한다면 그 문제를 어떻게 완화할 수 있을지를 이해하고 선제적으로 조치하는 것이다. 

</br>

### 자신에게 분명하다고 해서 다른 사람에게도 분명한 것은 아니다.

주석문을 많이 작성하라는 뜻이 아니다.

코드를 이해하기 쉽고 코드 자체로 설명이 되게 하는 것이 좋은 방법이다.

</br>

### 다른 개발자는 무의식중에 여러분의 코드를 망가뜨릴 수 있다.

코드는 독집적으로 존재하지 않는다. 여러 가지 다른 코드에 의존하고, 그 코드는 또다시 훨씬 더 많은 코드에 의존한다. 

다른 개발자가 기능을 추가하고, 리팩터링하고 수정함에 따라 코드는ㄴ 계속해서 변경된다.

</br>

### 시간이 지나면 자신의 코드를 기억하지 못한다.

1~2년 전에 작성한 코들르 다시 들여다보는 일은 다른 사람이 작성한 코드를 보는 것과 크게 다르지 않다. 배경지식이 거의 없거나 전혀 없는 사람에게도 자신의 코드가 이해하기 쉬워야 하고, 잘 작동하던 코드에 버그가 발생하는 것이 어려워야 한다. 

</br>

## 여러분이 작성한 코드의 사용법을 다른 사람들은 어떻게 아는가?

### 이름 확인

패키지, 클래스, 함수의 이름을 책의 목차라고 생각할 수 있다. 

자신의 코드를 다른 개발자가 어떻게 사용해야 하는지에 대해 가장 잘 전달할 수 있는 방법 중 하나는 이름을 잘 짓는 것이다.

</br>

### 데이터 유형 확인

컴파일이 필요한 정적 유형의 언어에서는 데이터 유형을 인식하고 올바르게 사용해야한다. 

따라서 유형 시스템을 사용하는 언어로 코드를 작성하는 것은 다른 개발자가 코드를 오용하거나 오작동할 수 없도록 하기 위한 좋은 방법 중 하나다.

</br>

### 문서 읽기

코드를 사용하는 방법에 관한 문서는 두 가지 이상의 형태로 존재할 수 있으며 다름을 포함한다. 

- 함수 및 클래스 수준의 비공식적인 주석문
- 자바독 JavaDoc과 같은 좀 더 공식적인 코드 내 문서
- 외부 문서

이 모든 것이 유용하지만 ..

다른 개발자가 이 문서들을 읽을 것이라는 보장이 없으며 실제로 읽지 않을 때가 많다. 

설령 읽더라도 잘못 해석할 수 있다. 

문서 업데이트가 제대로 안될 수 있다.

</br>

### 코드를 살펴보는 것

실용적이지도 않고 코드의 양이 많으면 효과를 얻기 힘들다. 

</br>

## 코드 계약

**선결 조건 (precondition)**

코드를 호출하기 전에 사실이어야 하는 것. 예를 들어 시스템이 어떤 상태에 있어야 하는지, 코드에 어떤 입력을 공급해야 하는지와 같은 사항

**사후 조건 (postcondition)**

코드가 호출된 후에 사실이어야 하는 것. 예를 들어 시스템이 새로운 상태에 놓인다든지 반환되는 값과 같은 사항

**불변 사항 (invariant)**

코드가 호출되기 전과 후에 시스템 상태를 비교해서 변경되지 않아햐 하는 사항 

</br>

### 계약의 세부 조항

**계약의 명확한 부분**

- 함수와 클래스 이름 : 호출하는 쪽에서 이것을 모르면 코드를 사용할 수 없다.
- 인자 유형 : 호출하는 쪽에서 인자의 유형을 잘못 사용하면 코드는 컴파일조차 되지 않는다.
- 반환 유형 : 호출하는 쪽에서 함수의 반환 유형을 알아야 한다. 이 유형과 일치하지 않는 유형을 사용하면 코드는 컴파일되지 않는다.
- 검사 예외 : 호출하는 코드가 이것을 처리하지 않으면 코드는 컴파일 되지 않는다.

**세부 조항**

- 주석문과 문서 : 실제 계약의 세부 조항에 대해 그렇듯이 꼼꼼하게 모두 다 읽어봐야 하는 것임에도 잘 읽지 않는다.
- 비검사 예외 : 주석문에 이 예외에 나열되어 있다면 이것은 세부 조항이다.

코드 계약에서 조건을 맹백하게 하는 것이 세부 조항을 사용하는 것보다 훨씬 낫다.

</br>

### 세부 조항에 너무 의존하지 말라

개발자들이 해당 코드를 사용할 때 모든 세부 조항을 다 알지 못할 가능성이 크다. 

**세부 조항을 제거하는 방법**

다른 개발자가 코드를 올바르게 사용하기 위해 세부조항에 의존하기보다 잘못된 일을 하는 것을 처음부터 불가능하게 만드는 것이 좋다. 코드 계약의 세부 조항에 있는 어떤 항목에 대해 발생 자체가 불가능하도록 (또는 적어도 실수할 가능성이 없도록 하는) 명백한 항목으로 바꾸는 것이 가능한 경우가 있다. 코드가 오용되거나 잘못 설정되면 컴파일조차 되지 않도록 하는 것이 목표다.

```kotlin
class UserSetting private constructor() {

    companion object {
        fun create(location: File): UserSetting? {
            // ...
        }
    }
}
```

위와 같은 방식으로 코드를 작성하면 상태(state)나 가변성(mutability)이 클래스 외부로 노출되는 것을 없앨 수 있다.

</br>

## 체크 및 어서션

컴파일러를 사용하여 코드 계약을 확인하는 것에 대한 대안으로 런타임 검사를 사용할 수 있다. 이 방법은 일반적으로 컴파일 타임 확인만큼 강력하지 않는데, 왜냐면 코드 계약 위반의 발견이 코드를 실행하는 동안 발생하는 문제에 대한 테스트에(또는 사용자)에 의존하기 떄문이다. 

→ 컴파일러는 애당초 계약 위반을 논리적으로 불가능하게 함

### 체크

코드 계약 조건을 확인하기 위한 일반적인 방법.

코드 계약이 준수되었는지(입력 매개변수에 대한 제약 조건 또는 수행해야 할 설정에 대한 제약 등) 확인하기 위한 추가 로직. 준수되지 않을 경우 체크는 실패를 유발하는 오류를 생성하는데, 이 실패는 명백해서 놓치고 넘어가는 것이 불가능하다. (체크는 신속한 실패와 밀접한 관련)

체크는 시행 중인 계약 조건에 따라 다음과 같은 범주로 구분된다.

**전제 조건 검사** : 예를 들어 입력 인수가 올바르거나, 초기화가 수행되었거나, 일부 코드를 실행하기 전에 시스템이 유효한 상태인지 확인하는 경우

**사후 상태 검사** : 예를 들어 반환값이 올바르거나 일부 코드를 실행한 후 시스템이 유효한 상태인지 확인하는 경우

체크를 사용할 때 기대하는 것은 코드가 오용된면 고객에게 배포되거나 실제 프로덕션에서 서비스 되기 전에 대발 단계나 테스트 단계에서 발견되고 수정되는 것이다.

</br>

### 어서션 assertion

코드 계약을 준수하도록 강제하기 위한 방법이라는 점에서 체크와 매우 유사하다. 조건이 위반되면 오류가 명백하게 보이거나 예외가 발생한다.

어서션과 체크의 주요 차이점은 배포를 위해 빌드할 때 어서션은 보통 컴파일에서 제외된다는 점이며, 이는 코드가 실제 서비스 환경에서 사용될 때 실패를 명백하게 보여주지 않는다는 것을 의미한다. 코드를 배포할 때 컴파일하지 않는 이유는 다음과 같다.

**성능 향상을 위해** : 조건이 위반되는지 확인하려면 CPU 사이클이 필요하다. 코드에서 assertion이 많으면 소프트웨어의 전반적인 성능이 눈에 띄게 저하될 수 있다.

**코드 오류 발생률을 낮추기 위해** : 이것이 유효한 동기인지는 특정 응용 프로그램에 달려있다. 이로 인해 버그가 눈에 띄지 않을 가능성이 증가하지만 버그 발생 가능성 방지보다 고가용성이 더 중요한 시스템이라면 배포 시에 컴파일에서 제외하는 것은 적절한 절충이 될 수 있다.
