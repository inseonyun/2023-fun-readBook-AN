# 3장. 다른 개발자와 코드 계약

소프트웨어 작성과 유지보수는 대개 팀 단위에서 수행하는 작업이다.
자신이 작성한 코드를 다른 개발자가 작업해야 하고, 반대로 다른 개발자가 작업한 코드를 자신이 작업해야 할 때도 있다.

## 3.1 자신의 코드와 다른 개발자의 코드

팀의 일원으로 코드를 작성할 때 추상화 계층 분리를 잘했다면 완전히 다른 문제에서 내가 작성한 코드가 재사용 될 수 있다.

내가 작성한 코드는 다른 개발자의 코드애 의존하고 다른 개발자들 역시 내 코드에 의존한다.

요구 사항이 항상 변하는데

개발자들이 코드베이스를 계속해서 수정을 가하면 그 코드베이스는 활동이 활발하게 일어나는 베이스가 된다.

활발하게 코드를 변경하더라도 코드의 품질이 유지되려면 튼튼하고 쉬워야한다.

가장 중요한 고려 사항 중 하나는 다른 개발자가 변경하거나 코드와 상호작용할 때 발생할 수 있는 문제는 없는지, 문제가 발생한다면 어떻게 완화할 수 있을지 이해하고 선제적으로 조치하는 것이다.

다음을 고려하라

### 자신에게 명백하다고 해서 다른 사람에게도 명백한 것은 아니다.

다른 개발자가 내 코드와 상호작용하거나 코드를 변경하거나 내 코드가 의존하고 있는 코드가 변경될 수도 있다.

해당 코드에 대해 많은 시간을 보낸 나에게 익숙해서 분명해 보이는 것이지 코드가 분명한 것이 아니다.

따라서 코드를 이해하기 쉽고 코드 자체로 설명이 되게 해야한다.

### 다른 개발자는 무의식중에 내 코드를 망가뜨릴 수 있다.

코드는 독립적으로 존재하지 않는다.

다른 개발자가 의도치 않게 잘 실행되던 코드를 작동하지 않게 하거나 오용하는 방식으로 코드를 추가하거나 수정할 수 있다.

### 시간이 지남에 따라 자신의 코드를 기억하지 못한다.

앞에서 얘기한 두 가지는 미래의 나에게도 적용된다.

## 3.2 여러분이 작성한 코드의 사용법은 다른 사람들이 어떻게 아는가?

코드를 어떻게 사용해야 하는지 그 코드가 무슨일을 하는지 구체적으로 파악해야 한다.

- 여러 가지 상황에서 어떤 함수를 호출해야 하는지
- 클래스가 무엇을 나타내는지 그리고 언제 사용되어야 하는지
- 어떤 값을 인수로 사용해야 하는지
- 코드가 수행하는 동작이 무엇인지
- 어떤 값을 반환하는지

다른 개발자가 할 수 있는 일

- 이름 확인
- 데이터 type을 확인한다.
- 주석을 읽어본다. (다른 개발자가 문서를 읽을 것이라는 보장도 없고 잘못 해석할 수 있으며 업데이트가 안될 수 있다)
- 직접 물어본다. (작성한지 얼마 안됐다면 효과적이지만 장기적으로 신뢰하기 어려운 방법이다)
- 코드를 살펴본다.(실용적이지 않다 읽어야할 코드가 너무 많다)

## 3.3 코드 계약

**Programming by Contract, Design by Contract**

다른 사람들이 어떻게 코드를 사용할 지, 무엇을 기대할 수 있는지 공식화한 것이다.

코드간의 상호작용은 마치 계약

계약에 대한 용어로 다음 세 가지 범주로 나눈다.

- Precondition(선결) : 코드가 호출하기 전에 사실이어야 하는 것. (이전 상태, given)
- PostCondition(사후) : 코드가 호출된 이후 사실이어야 하는 것. (이후 상태, then)
- Invariant(불편 사항) : 코드가 호출되고 나서 변경되지 않아야 하는 사항

입력 매개변수가 있는 함수를 작성하거나, 값읇 반환하거나, 어떤 상태를 수정하면 계약을 생성한 것이 되는데

입력 조건 -> 기대가 존재하기 때문이다

개발자가 계약을 제대로 알지 못하면 문제가 발생한다.

### 계약의 세부 조항

- 계약의 명백한 부분
  - 함수와 클래스 이름
  - arguments type
  - return type
  - checked Exception

- 세부 조항
  - 주석문과 문서
  - unChecked Exception

조건을 명백히 하는 것이 세부 조항 사용보다 훨씬 낫다.

### 세부 조항에 너무 의존하지 말라

세부사항에 의존하는 것을 피할 수 없는 경우가 있다.

어떤 문제들은 항상 주의사항이 있고 이것을 설명해야한다. 혹은 어쩔 수 없이 저품질의 코드에 의존해야 하는 경우일 수 있다.

그에 맞춰서 짜다보면 이상한 코드가 나올 수 있는데 이때 문서가 필요하다.

그런 상황이 있을 수 있지만 일반적으로 문서에 의존하지 않는 것이 바람직하다.

**코드를 요용할 수 있는 방법이 많을수록 실제로 오용되고 소프르웨어에 버그가 있을 가능성이 크다**

책에서 코드를 개선하는 방법으로 정적 팩토리 메서드를 예시로 들고있다.
-> 필요한 값 로딩과 초기화 작업이 처리하고 유효한 상태일 때만 클래스의 인스턴스를 반환한다.

즉, 오용하기 것이 불가능하기 만들어 버그가 침투할 가능성을 줄여라.

## 3.4 Check & Assertion

컴파일 타임 코드 계약 확인의 대안 런타임 검사

컴파일보다 강력하지 못한데 그 이유는 테스트(또는 사용자)에 의존하기 때문이다. 

애당초 계약 위반을 불가능하게 만드는 컴파일 타임 확인과 대조적이다.

하지만 컴파일러를 사용하여 계약을 강제하지 못할 때는 사용해야 한다.

### Check

계약 조건을 확인하기 위한 일반적인 방법 check

코드 계약이 준수되었는지 확인하기 위한 추가 로직 실패하면 오류를 생성 (kotlin check(), require() 등)

- 전제 조건 검사 : 인수의 올바른 입력, 초기화 수행, 일부 코드를 실행하기 전에 시스템이 유효한 상태인지 확인
- 사후 상태 검사 : 반환값이 올바르거나 일부 코드를 실행한 후 시스템이 유효한 상태인지 확인

잚못 설정되는 것을 불가능하게 만들어서 오류를 줄일 수 있다.

Check 를 사용하면 기대되는 것은 코드가 오용되면 고객에게 배포되거나 실제 프로덕션에서 서비스되기 전에 개발 단계나 테스트 단계에서 발견되고 수정되는 것이다.

- 테스트하기 불분명한 상황에서 조건이 위반된다면 코드가 배포되고 사용자가 사용하기 전까지 버그가 노출되지 않을 수 있다.
- Check 가 잘 작동해서 실패가 명백해도 아무도 알아차리지 못할 위험이 있다. 예외를 잡고 로그를 기록했는데 로그를 신경쓰지 않는다면 심각한 문제가 발생할 것이다.

코드에 Check 가 많이 있으면 세부 조항을 없애는 것에 대해 고려해봐야 할 수도?

### Assertion 

많은 언어에서 assertion 을 지원한다. 

개발 모드에서 컴파일 되거나 실행될 때 Check 와 거의 같은 방식으로 작동.

조건이 위반되면 오류가 명백하게 보이거나 예외가 발생한다.

Check 와 차이점은 배포를 위한 빌드 시 보통 컴파일에서 제외된다. 

서비스 환경에서 실패를 명백하게 보여주지 않는다. 
성능 향상을 시키고, 코드 오류 발생률을 낮추기 위해 배포할 떄 컴파일 하지 않는다.

Check 에서 언급되었던 상황은 Assertion 에서도 해당된다.
