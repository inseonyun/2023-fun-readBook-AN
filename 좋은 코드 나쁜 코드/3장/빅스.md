가장 기억에 남았던 부분은 `UserSetting` 클래스로 든 예시였다.

누군가에겐 당연하다고 생각될 수 있지만, 나는 실제로 책의 예시처럼 세부조항에 의존한 코드를 작성한 적이 있었기 때문이다.

토큰을 관리하는 SharedPreference를 만들 때 object 키워드로 선언하여 싱글톤으로 만들었다.

sharedPreference를 사용하려면 context가 필요하기 때문에 object내에 init(context: Context)를 두어서 컨텍스트를 받아올 수 있도록 하였다.

사용을 하기 위해선 init(context: Context)를 먼저 호출해야만하는 형태였다. 정말 예시와 똑같은 오류를 범했던 것이다.

그리고 레벨2 당시 산군이었나.. 누구였는지는 기억나지 않지만, 리뷰어에게 이런 init함수에 대해 리뷰를 받은 적이 있었다.<br>
_"과연 다른 개발자가 사용 전에 init함수를 호출해야한다는 것을 알 수 있을까요?"_

그래서 지금은 object가 아닌 class 키워드로 만들어 생성자 매개변수로 context를 받도록 하고 있다.

이제는 리뷰도, 책의 내용도 너무 잘 이해할 수 있다. 내가 작성했던 코드는 정말 오해를 불러일으키기 쉬운 코드였다.

_ _ _

다음으로 생각해본 내용은 책에서는 주석과 문서를 최대한 지양하라고 한다.

내가 이 부분을 읽으면서 든 생각은.. _"우리는 안드로이드 내부 코드나 주석, 공식문서를 맨날 읽는데?"_

내부 구현 코드를 전부 읽어보지는 않지만 내부에 들어가서 코드 주석은 종종 읽는 편이다.<br>
근데 책에서는 거의 안 읽을 것 처럼 얘기해서.. _"그럼 구글이 개발을 잘못한건가~?"_ 하는 불충한 생각을 해봤다! ㅋㅋ

_ _ _

우리는 레벨 1 동안 원시값 포장을 배우면서 `check`나 `require`를 사용해서 값에 대한 조건을 검사하곤했다.<br>
그땐 단순히 _"잘못된 값이 들어오면 터져야지!"_ 라는 생각으로 작성했다.

그런데 이번에 책에서 이에 대해 좀 더 명시적으로 설명해줘서 좋았다.

우선 체크를 사용하는 이유는 실패를 명백하게 해서 놓치지 않도록하기 위함이다. 즉 신속하게 실패하기 위함이다.<br>
신속하게 실패하는 이유는, 코드가 잘못 작성됐을 때 고객에게 배포되거나 실제 프로덕션에서 서비스되기 전에 개발 단계나 테스트 단계에서 발견하기 위함이다.

이 부분을 읽고 체크를 사용해야하는 이유가 좀 더 와닿았달까? (프로덕션보다는 개발 단계를 위한 것이었다는 부분)

또한 체크를 두 가지 범주로 구분한다는 것도 알게 되었다.<br>
`전제 조건 검사`와 `사후 상태 검사`가 있다.<br>
우리는 지금까지 전제 조건 검사만 했던 것 같다. 체크로 사후 상태도 검사한다는 것을 알았다.
