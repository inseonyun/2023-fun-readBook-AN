# `1. 안드로이드와 모델 뷰 컨트롤러`
### 책으로는 2장(41~61)

기본 생성자에 대해서.

@StringRes 의 장점
1. 컴파일 시점에 Lint가 검사해준다. ⇒ 런타임 에러를 막을 수 있다.
2. 가독성

일반적으로 비즈니스 로직을 처리하는 클래스가 아니라면, 데이터를 담는 용도이기 때문에 이런 클래스는 데이터 클래스로 선언해서 이점을 챙겨가자
데이터 클래스는 컴파일러가 자동으로 주요 함수 5가지를 생성해준다. (equals, hashCode, toString, componentN, copy)

# MVC
### 안드로이드 API는 모델-뷰-컨트롤러 아키텍처에 맞게 설계되어 있다고 한다.
애플리케이션의 모든 객체는 **모델, 뷰, 컨트롤러** 역할 중 하나에 해당해야 한다.

## 모델
⇒ 뷰를 모른다.
데이터와 비즈니스 로직을 가져야 한다.
모델 클래스는 앱과 관계된 것들을 **모델링**을 거쳐서 나온 것들이다.

## 뷰
뷰 객체는 자신을 화면에 그리는 방법(액티비티는 setContentView로 자신을 그린다)과 터치와 같은 사용자 입력에 응답하는 방법을 정의한 객체다.
**뷰계층**은 애플리케이션 내 뷰 객체들로부터 구성된다. xml 로부터 인플레이트되는 위젯들로 구성된다.

## 컨트롤러
⇒ 뷰와 모델을 연결한다
애플리케이션 로직을 포함하고 있다.
뷰 객체가 받는 이벤트들에 대해서 응답을 제공해준다.
모델과 뷰 사이를 연결하며 데이터 흐름을 관리한다

컨트롤러는 **액티비티** 혹은 **프래그먼트** 에 해당한다.


# 계층 분리를 하면 생기는 이점
## 계층 분리를 하면 클래스의 책임이 제한되게 되고 이로인해 클래스 재사용성도 자연스럽게 높힐 수 있다
⇒ Question 클래스는 뷰계층에 위치하지 않으므로 뷰와 관련된 것을 보여주기위한 로직과 메소드들이 필요없다. 이로인해 가벼운 클래스가 되었고 Quesiton 클래스를 다른 목적으로 사용하기 쉽게 된다.

MVC로도 더이상 컨트롤러(액티비티)를 가볍게 하는데 한계가 온다면, 그때 MVVM을 생각하라고 한다.

# 이 책에 나온 안드 개발 관련 팁들
### tools: 네임스페이스  를 사용해서 디자인시 사용하자.
이런 네임스페이스는 루트뷰에 위치시키자.

### 문자열 리소스에서 개행을 하고 싶다면, 줄바꿈문자(n) 앞에 이스케이프 시퀀스 문자(₩)을 넣어야 한다.
### 작은 따옴표인 아포스트로피(’)도 앞에 이스케이프 시퀀스 문자를 붙여야 한다.

# 컨트롤러 계층 변경
### 액티비티에서 텍스트뷰의 setText에 스트링 리소스를 넣어도 된다. 사실 처음 알았다.

# 아이콘 추가하기
이미지가 저장되는 디렉토리는 **장치의 화면 픽셀 밀도**를 나타내는 수식자들별로 다양하게 존재한다

mdpi: 중밀도 => 160 dpi

hdpi: 고밀도 => 240 dpi

xhdpi: 초고밀도 => 320 dpi

xxhdpi: 극초밀도 => 480 dpi

xxxhdpi: 궁극초고밀도 => 640 dpi

=> dpi뜻: 1인치에 들어가는 픽셀의 개수. 160dpi는 1인치에 픽셀 160개가 들어간다는 것

⇒ 해상도만 다른 동일한 이미지들(책 54쪽에 표현이 나와있다.. 해상도와 화면 픽셀 밀도는 같은 말인 것 같다)

⇒ 이 중 가장 디바이스의 화면 픽셀 밀도에 적합한 이미지를 안드로이드 운영체제가 선택한다.

안드로이드 리소스 시스템이 결정한다고 한다. 자세한 내용은 3장에서 소개한다고 한다

해상도 별 디렉토리들이 res 디렉토리 아래에 없다면, 별도로 추가해줘야 한다

res/drawable 디렉토리 아래에는 어떠한 이미지 파일도 추가 가능하다(png, jpg, gif)
=> gif도 되는구나

추가된 이미지 파일에는 자동으로 리소스 id가 부여된다.

# 화면 픽셀 밀도

텍스트 크기는 텍스트 픽셀 높이.

마진: 각 뷰 간 간격

패딩: 한 뷰의 바깥 테두리와 내부 콘텐츠 간의 간격

## 화면 픽셀 밀도에 따라 시스템이 선택하는 이미지가 달라진다. 그렇다면, 이미지 크기가 디바이스마다 다르게 보여도 괜찮을까? ⇒ 안된다.

이를 위해서, 안드로이드에서는 밀도에 독립적인 크기 단위를 제공한다.

이 단위를 사용하게 되면, 서로 다른 밀도를 갖는 화면에서도 동일한 사이즈의 이미지를 볼 수 있다.

어떻게 이런일이 가능할까? 안드로이드가 런타임시에 디바이스의 픽셀 밀도에 따라 그 단위를 픽셀로 변환한다.

### 단위 종류
- px: 화면 밀도와는 무관한 단위. 1픽셀은 화면의 1픽셀이다.  사용을 권장하지 않음. 디바이스마다 크기가 다르게 나옴. 고밀도일수록 픽셀의 크기가 작다는 것이므로 크기가 더 작게 그려질 것이다. 
- dp(=dip):  ‘밀도와 독립적인 픽셀’ 이라는 의미. 1dp는 항상 모든 디바이스를 기준으로 1/160의 크기를 갖는다. 즉, 안드로이드의 기준 dpi는 mdpi다.
- sp: ‘크기 독립적 픽셀’ 이라는 의미. 사용자의 폰트 크기도 고려한 dp. 텍스트에 주로 사용한다.

dp와 sp는 런타임 시에 픽셀로 변환된다.

#### dp 에서 px 변환 공식
- dp에 단말기의 dpi를 곱하고 160으로 나누면 px이 된다
- px에 160을 곱하고 단말기의 dpi를 나누면 dp가 된다.

### 화면 픽셀 밀도 종류 중 mdpi 에서 px, dp, sp는 크기가 같다

dp와 sp는 사용자가 디바이스의 글자 크기를 조정하지 않는 한 똑같다.

단, 글자 크기를 조정하게 된다면 sp는 커지게 된다

# 챌린지

ImageView의 contentDescription 속성: 시력이 안 좋은 사용자들을 지원한다. 해당 문자열이 큰 소리로 읽힐 수 있다.
