# 30장) 커스텀 뷰와 터치 이벤트

커스텀 뷰의 구분

- 단순: 자식 뷰가 없는 커스텀 뷰
- 복합: 서로 다른 뷰 객체들로 구성된 커스텀 뷰. 렌더링을 각 자식들에게 위임.

### 단순 커스텀 뷰를 만들 때는 View를 부모 클래스로 많이 선택함.

View는 빈 캔버스(도화지)와 같다.

### 복합 커스텀 뷰를 만들 때는 FrameLayout과 같이 적합한 레이아웃 클래스를 선택함.

# 커스텀 뷰 만들기

```kotlin
class BoxDrawingView(
	context:Context,
	attrs:AttributeSet? = null
):View(context,attrs) { 

}
```

⇒ 레이아웃 파일로부터 인플레이팅되어서 초기화되는 뷰는 우리가 xml상에서 지정한 속성값들을 포함하는 AttributeSet 객체를 받게 된다.

### 우리가 xml에 뷰에 대한 태그를 달 때, 해당 뷰 클래스의 경로를 지정해주는 이유는?

레이아웃 인플레이터가 그 클래스를 찾을 수 있게 하기 위해서

⇒ 안드로이드 기본 제공 패키지 아래 있는 뷰가 아니라면, 그 뷰 클래스의 패키지 전체 경로명을 적어줘야 한다.

# 뷰의 터치 이벤트 리스너 제어하기

우리가 View.OnTouchListner를 구현해서 해당 뷰에게 리스너를 달아주면, 이 뷰에 터치이벤트가 발생할 때마다 우리가 구현한 리스너의 onTouchEvent(event: MotionEvent): Boolean 이 호출된다.

- 여기서 MotionEvent는 터치 이벤트 그 자체를 나타내며, 화면을 터치한 위치와 액션을 소유하고 있다.
    - 액션은 액션 상수로 표현되는데, ACTION_DOWN, ACTION_MOVE, ACTION_UP, ACTION_CANCEL 총 네 가지가 있다.
        - 여기서  ACTION_CANCEL 은 이름을 보고 알아채기 쉽지 않을 수 있다. 이 녀석은 ‘부모 뷰가 터치 이벤트를 가로챔’ 이라는 의미다.
    - 터치한 위치는 x와 y 프로퍼티로 접근이 가능하다.

### PointF 클래스

x와 y좌표를 넣는 역할로 사용할 수 있는 안드로이드 기본 제공 컨테이너 클래스.

# 다운→드래그→업   으로 박스그림 추가하는 로직 작성하기

- ACTION_DOWN 모션 이벤트가 발생하면, 그 지점을 박스의 시작 위치로 잡고 객체를 만든다. 그리고 이걸 현재 그리고 있는 진행중인 박스 객체로 지역변수에 저장한다.
- ACTION_UP 이나 ACTION_CANCEL이 발생하면, 진행중인 박스 객체인 지역변수를 NULL로 초기화해준다. 즉, 사용자가 이번 턴에서 박스 그리기를 마쳤다는 것임.

모든 액션 이벤트 발생한 후에, updateCurrentBox(PointF)를 호출한다. 그리고 그 안에서는 invalidate를 호출함.

### invalidate()

뷰가 무효(invalidate)라는 것을 안드로이드 시스템에게 알림. 해당 뷰의 변경 사항을 반영해서 다시 그려준다.

⇒ 여기서는 우리가 드래그 하는 동안에도 updateCurrentBox 를 호출하므로, 실시간으로 박스의 모양 추적이 된다.

- 참고 꿀팁

  처음 앱이 시작될 때, 모든 뷰가 무효 상태라서 다들 그릴 수 없는 상태라고 한다. 기준이 없어서 그런듯.

  이때, 최상위 뷰의 draw()를 안드로이드 시스템이 호출한다고 한다.

  그러면, 뷰 계층을 따라 내려가면서 자식 뷰들의 또 다른 자식 뷰들도 자신들을 그리게 된다고.

  그리고 모든 자식들이 그려질 때, 최상위 뷰도 무효 상태를 벗어난다고 함.


### onDraw()

실질적으로 뷰를 다시 그리는 함수임.

invalidate()가 호출되면, onDraw(Canvas)가 호출된다고 함.

- Canvas와 Paint 다시 알고가기
    - Canvas: 모든 그리기 함수를 가짐. 선, 원, 사각형 등을 그릴 수 있음
    - Paint: Canvas가 가진 함수들을 꾸며주는 역할. 무슨 색 사용할건지, 내부를 채울건지, 글자는 무슨 폰트를 사용하것인지 등을 지정 가능하게 해준다.

```kotlin
val boxPaint = Paint().apply{ color = 색시정 }
val backgroundPaint = Paint().apply{ color = 색지정 }

override fun onDraw(canvas:Canvas) {
	canvas.drawPaint(backgroundPaint)
	
	boxen.forEach { box ->
		canvas.drawRect(box.left, box.top, box.right, box.bottom, boxPaint)
	}
}
```

# 궁금증 해소하기: GestureDetector

터치이벤트를 처리하는 또 다른 방법임. 터치이벤트 리스너를 어느정도 커스텀해놔서 밀어서 스크롤, 두번 클릭 등과 같이 자주 사용되는 이벤트에 대해 미리 정의된 리스너 함수들을 많이 제공해줌.

# 챌린지: 상태 정보 저장하기

회전과 같은 장치 구성 변경시, 뷰 내부적으로 자신의 상태를 저장 및 복원이 가능하다.

여기에도 저장, 복구와 같은 함수 두 개가 존재함.

### 액티비티나 프래그먼트의 저장,복구 메소드들과의 차이점

- 뷰가 id를 가져야만 호출된다
- 커스텀 뷰라면, 부모 클래스의 상태 정보도 저장,복구하기위해 신경 써야 한다고 함.

# 챌린지: 박스의 방향 회전

다수 처리할 경우 고려할 사항들

- 포인터 인덱스
- 포인터 ID
