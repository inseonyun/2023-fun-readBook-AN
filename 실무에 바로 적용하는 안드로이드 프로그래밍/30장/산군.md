# Looper, Handler, HandlerThread

centerCrop에 대해

드로어블 리소스에 접근해서 Drawable객체를 얻어내는 방법
ContextCompat.getDrawable(컨텍스트, 리소스id)


안드로이드에서는 메인 스레드에서 네트워크 작업을 할 수 없다.
@WorkerThread 애노테이션은 백그라운드 스레드에서 수행되어야 함을 나타낸다.
그렇다고. 이 애노테이션을 붙인다고 작업 스레드에서 수행되는 것은 아니다.

(하지만, 이와 다르게 @MainThread나 @UiThread 애노테이션은 지정되면 자동으로 mainThread에서 실행된다)

Closeable 인터페이스를 구현한 객체를 코틀린 표준 라이브러리 함수인 use를 사용하면 자동으로 닫아야 할 일들을 수행한다.

비트맵이란?

실무에서는 이미지 같이 메모리 차지 비용이 큰 것들은 화면에 나타날 필요가 있을 때만 다운로드한다.

필요할때(보여져야 할때) 다운로드하는 것은 리사이클러뷰와 그 어댑터가 할 일이다.

# HandlerThread
인스타의 좋아요 버튼을 누를때마다 스레드를 생성해서 실행시킨다면, 스레드를 시작시킨 순서대로 DB에 반영되지 않을 수 있다.
때문에 이런 경우는 HandlerThread를 사용해서 실행 순서를 맞춰줘야 한다.

### HandlerThread는 Thread 클래스를 상속하고 내부에서 Looper.prepare와 Looper.loop를 실행하는 루퍼 스레드다.

핸들러 스레드는 기본적으로 메인스레드와는 무관하다.
다만, 단일 스레드 내에서 순차적인 작업이 필요할 때 사용하면 된다.

→ 그냥 이 스레드의 메시지 큐에 들어갈 수 있는 메시지 객체들 중 놀고 있는 놈 하나를 가져와서 obj멤버에 담을 내용들을 담고, sendMessage로 다시 메시지큐에 보낸다.

그러면 루퍼가 큐 순서대로 수행해준다.

# 생명주기 인식 스레드

프래그먼트를 유보(retain)한다는 것은 회전으로 인해 구성 변경이 생기더라도 그 시점의 프래그먼트 인스턴스가 갖고 있던 상태 데이터를 계속 보존한다는 의미.

프래그먼트의 onCreate단계에서 retainInstance를 true로 설정한다.

(프래그먼트는 유보를 권장하지는 않는다고 한다)

프래그먼트의 생성 혹은 소멸 단계에서 스레드를 시작시키고 중단시키고 관리하는 것은 복잡하다.

따라서, **핸들러스레드를 상속받은 클래스에 관련 코드를 추가해서 생명주기를 인식하는 백그라운드 스레드를 만들것이다.**

1. 생명주기 관찰자
2. 생명주기 소유자: 액티비티와 프래그먼트는 생명주기 소유자다. LifeCycleOwner 인터페이스를 구현한다.

⇒ 핸들러 스레드를 상속받은 클래스에, LifecycleObserver를 구현하도록 만들어서, 자신이 관찰하는 생명주기 소유자의 onCreate나 onDestory 등의 함수를 관찰하도록 만들 수 있다.

@OnLifecycleEvent(Lifecycle.Event.ON_CREATE)

⇒ 라이프 사이클 오너의 onCreate가 호출될 때 실행되는 메소드에 붙이면 되는 애노테이션

@OnLifecycleEvent(Lifecycle.Event.ON_DESTROY)

⇒ 라이프 사이클 오너의 onDestroy가 호출될 때 실행되는 메소드에 붙이면 되는 애노테이션

## 해당 생명주기의 구독자를 등록하는 방법

생명주기 소유자의 addObserver 메소드를 사용해서 구독자를 추가한다.

그리고 해당 생명주기 소유자가 파괴될때, removeObserver로 관찰자들을 풀어줘야 한다. 메모리 누수를 막기 위해

## 스레드 시작 시키기

생명주기 소유자의 온_크리에이티드가 시작되면, start()로 스레드를 시작시키고, looper를 사용해서 심각한 스레드 경합? 상태를 방지 가능하다.

생명주기 소유자의 온_디스트로이가 시작되면, quit()로 스레드를 중단시켜야 한다. 만약 이걸 끄지 않는다면, 좀비처럼 살아있데 된다고 한다.

바인드 될때 이미지가 불러와지도록 어댑터에서 해당 스레드의 특정 메소드를 호출해준다.

# 메시지와 메시지 핸들러

**스레드가 사용하는 메시지 수신함(우편통) == 메시지 큐**

메시지 큐를 사용해서 동작하는 스레드 == 메시지 루프

⇒ 스레드는 메시지 큐에서 새 메시지를 꺼내서 반복해서 루프를 실행한다.

메시지 루프는 하나의 스레드와 하나의 루퍼로 구성된다.

**루프 = 스레드 한 개  + 한 개의 루퍼**

**루퍼는 스레드의 메시지 큐를 관리한다.**

루퍼를 갖는 작업 스레드를 만들고 싶다면, 즉, 루프를 만들고 싶다면, 루퍼를 준비해줘야 하는데, 이런 준비를 자동으로 해주는 HandlerThread에게 감사합니다.

### A스레드에서 B스레드의 메시지 큐에 메시지를 넣고 싶다면, 핸들러를 이용해야 한다.

# 메시지 구조

- what: 메시지의 사용자 정의 정수값, 키로 사용되는 값이라고 생각하면 된다.
- obj: 메시지와 함께 전달되는 사용자 지정 객체
- target: 메시지를 처리할  Handler

메시지가 처리될 준비가 되면, 이 처리를 핸들러 객체가 맡는다.

⇒ 핸들러는 메시지를 메시지큐에서 뺐다가 다시 넣는 등의 처리 역할을 한다.

# 핸들러 구조

Handler는 메시지를 처리하는 대상이면서, 메시지를 생성하고 게시하는 인터페이스다.

### 루퍼는 메시지를 소모하는 소비자다. 즉, 루퍼가 메시지 큐에서 메시지를 꺼내서 까고 수행한다. 루퍼는 메시지큐와 연결되어 있다.

핸들러는 정확히 하나의 루퍼에 연결된다. ⇒ 별도로 루퍼를 등록하지 않으면, 그 핸들러가 생성된 스레드의 루퍼와 연결된 핸들러가 만들어진다.

다수의 핸들러가 하나의 루퍼에 연결될 수 있다.

⇒ 즉, 핸들러와 루퍼는 n:1. 관계가 가능하다.

Handler.obtainMessage() → 공유되는 메시지 풀에서 메시지 객체 하나를 반환한다.

여기에서 what, obj, target을 지정 가능하다.

만약, target을 지정하지 않는다면, 해당 핸들러가 이 메시지의 처리 핸들러가 된다.

Handler.sendToTarget() → 해당 메시지를 이 핸들러와 연결된 루퍼의 메시지큐 맨 끝에 넣는다.

루퍼는 메시지를 큐에서 꺼내고, 이 메시지가 참조하는 대상 핸들러에 전달해서 이 메시지를 처리하게 만든다.

이때 대상 핸들러의 handleMessage(message:Message) 가 실행되고 여기서 처리된다.

ConccurrentHashMap은 스레드 안전한 해쉬맵이라고 한다. 지금 당장 중요한건 아님.

책의 HandlerThread 구현체인 ThumbnailThread의 queueThumbnail 메소드는 메시지를 작업 스레드의 메시지큐 뒤에 보내는 역할을 하고 있다.

ThumbnailThread 자체가 지금 작업스레드임.

여기서 만든 핸들러가 지금 루퍼 지정이 없으므로, 해당 작업 스레드가 가진 루퍼에 메시지를 전달하는 핸들러가 된다.

메인스레드의 루퍼에 대한 참조를 갖는 핸들러가 있을 경우, 메모리 누수를 조심하자.

내부 클래스 인스턴스가 외부 클래스의 인스턴스보다 오래 존재하면 메모리 누수 가능성 언급

메인스레드는 여러 핸들러와 하나의 루퍼를 갖는 메시지 루프.

메인스레드에서 핸들러를 그냥 선언하면, 별도 루퍼 지정없어도 메인스레드의 메시지큐에 메시지 요청을 보내는 핸들러가 된다.

이걸 다른 스레드에서 사용해서 메시지를 얻고, 내용을 담아서, 보내면 이게 연결된 루퍼 즉, 메인스레드의 메시지 큐로 된다.

책 568

⇒  응답 핸들러==  메인 루퍼와 연결된 핸들러

⇒   작업스레드에서 다운로드를 마친뒤 실행할 콜백함수

핸들러의 post메소드는 자신과 연결된 루퍼가 참조하는 메시지 큐에 해당 Runnable 객체의 내용을 메시지에 담아서 보낸다.

hasQuit라는 변수가 필요한 이유: 이 스레드는 지금 생명주기 인식 스레드이기 때문에

이 스레드가 관찰하는 생명주기주인이 파괴될 때, 이 스레드도 멈추도록 어있다.

하지만, 이미 메인스레드의 메시지큐에 보냈던 메시지들을 회수할 수는 없기 때문에,

이 메시지의 차례가 될 때 , 이 메시지의 처리를 수행하지 않겠다는 의미다.

### 지금 구조에서 회전을 하면 터지는 이유

프래그먼트의 홀더객체들도 모두 파괴되고 새로 만들어지게 될 것이기 때문임.

그런데, 우리의 메시지 내용들은 과거의 뷰홀더들을 사용하고 있음.

참고: 현재는 프래그먼트의 상태를 유보중이다. 즉, 회전을 하더라도 프래그먼트 객체의 살아있으나, 뷰만 파괴되는 상태임.

즉, ThumbnailDownloader라는 핸들러 스레드는 프래그먼트의 생명주기 뿐만 아니라, 프래그먼트 뷰의 생명주기도 인식해야 한다.

⇒ 안에 생명주기 관찰자 객체를 두 개 만들어야 한다.

# 프래그먼트의 viewLifecycleOwner.lifecycle

프래그먼트는 lifecycle과 위에서 언급한 뷰의 라이프사이클 오너 총 두개를 갖는다.

각각에 대해서 관찰자를 추가 해줄 수 있다.

프래그먼트 뷰 생명주기 관찰자는 프래그먼트 뷰가 생성된 시점인 onCreateView 안에서 해주면 된다.

onDestoroyView에서는 뷰의 생명주기 관찰자들을 해제해줘야 한다

575 프래그먼트 생명주기 그림 잘 보자.
