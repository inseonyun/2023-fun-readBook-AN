# 프래그먼트와 프래그먼트 매니저

# UI 유연성을 위해 프래그먼트를 사용해라

액티비티는 유연성을 고려하고 설계되지 않음.

액티비티는 사용하는 특정 화면과 강하게 결합되어 있음.

# 프래그먼트

프래그먼트는 액티비티의 작업 수행(UI관리)을 대신 해줄 수 있는 컨트롤러 객체다

ui프래그먼트는 레이아웃 파일로부터 인플레이트 되는 자신의 뷰를 하나 갖는다.

⇒ 프래그먼트 객체와 프래그먼트 뷰는 서로 다른 개념이다

액티비티는 프래그먼트를 집어 넣을 컨테이너를 가져야 한다.

이 컨테이너에는 인플레이트된 프래그먼트 뷰가 추가될 수 있다.

만약 리스트에서 새로운 요소를 선택하면 디테일 프래그먼트 객체를 새로 만들어서 위에 올려도 된다.

(이게 좋은 방법인지는 모르겠지만 이런 방법도 있는듯?)

UI프래그먼트를 사용함으로써, 앱의 UI를 조립 가능한 요소로 분리할 수 있다.

(프래그먼트 사용 시 유용한 제트팩 라이브러리 소속의 (네비게이션 컨트롤러))

# CriminalIntent 앱을 만들기

### 호스팅이란?

액티비티가 자신의 뷰 계층 구조에 프래그먼트와 그 뷰를 포함하는 곳을 제공한다. 이게 바로 호스팅임.

→ 액티비티가 프래그먼트를 호스팅한다고 표현한다.

### 객체 다이어그램이란?

큰 프로젝트의 구조를 이해하는데 도움이 되는 용도로 만든다.

![image](https://github.com/woowacourse/android-shopping-order/assets/67176829/232d2201-4e1f-408a-a0e9-f5c8a062e147)

MVC 구조 기준으로는 아래와 같이 나눈다.

- 모델
- 컨트롤러(액티비티/프래그먼트)
- 뷰(레이아웃)

### 뷰의 스타일 지정하기

style = “?android:listSeparatorViewStyle” 을 지정해주면 된다.

⇒ 나중에 10장에서 배운다고 한다.

android.app.Fragment와 androidx.fragment.app.Fragment 는 호환성 지원 여부의 차이다.

# 프래그먼트

프래그먼트는  API 레벨 11에 도입되었다고 한다.

28레벨 이전 까지만 프레임워크에서 기존 제공하는 프래그먼트를 지원하다가 이제는 이것마저도 업데이트 해주지 않는다.  또한, v4 라이브러리가 제트팩에 흡수되어서 v4라이브러리에 속한 프래그먼트도 이제는 사용안된다.

제트팩 라이브러리에 속한 프래그먼트를 사용해야 한다.

이전 플젝에서 프래그먼트를 사용했다면, 모두 제트팩으로 바꿔야 한다고 한다.

# 프래그먼트 생명주기

대부분의 프래그먼트 생명주기 함수들은 액티비티와 유사함.

하지만, 프래그먼트 객체 자체와 프래그먼트와 연결되는 뷰는 별도라는 점에서 생명주기 함수의 차이가 조금 있다.

기본적으로 프래그먼트의 onCreate와 액티비티의  onCreate는 둘 다 객체를 초기화하는 메소드다.

차이점: 액티비티는 객체가 생길때 액티비티 위에 보일 뷰도 인플레이팅 되어야 한다.

왜냐하면, 액티비티는 객체와 뷰가 함께 생기고 사라지는 녀석이기 때문이다.

프래그먼트는 onCreate에서는 프래그먼트 객체 자체에 대한 초기화만 수행되고, 프래그먼트 뷰는 초기화 되지 않음.

프래그먼트 뷰는 onCreateView에서 생성된다. 이 메소드에서는 인플레이팅한 뷰를 반환해줘야 한다. 그러면 그걸 호스팅 액티비티가 받는다.

```kotlin
val view = inflater.inflate(R.layout.fragment_crime, container, false)
return view
```

이때, LayoutInflater 클래스의 inflate메소드는 인자를 세개 갖는다. 각각의 의미는?

첫 번째: 인플레이팅할 레이아웃 리소스의 id

두 번째: 이 뷰를 올릴 뷰그룹

세 번째: 이 뷰를 해당 뷰그룹에 바로 올릴지 말지

⇒ 액티비티가 나중에 판단해서 올릴 것이므로 우리는 false를 줘야 한다. 안그러면 터진다.

액티비티에서 우리가 findViewById를 호출하던 것은 편의상 액티비티에서 제공되는 래핑? 구조의 메소드다.

내부적으로는 해당 액비비티의 뷰 객체의 findViewById를 호출하는 것이다.

onStart에서 리스너들을 달아준다?

흠;; onViewCreated에서 해줘도 되는거 아닌가? 싶다.

⇒ 아,… 왜 onStart에서 리스너를 달아줬을까?

화면 회전 등으로 인해, 뷰 시스템 상에서 뷰의 상태를 자동 복원(EditTextView의 입력 상태 값, 체크박스의 체크여부값 등)하는 곳의 위치가 **onCreateViewd 호출 이후와  onStart 호출 전 사이**이기 때문이다.

즉, 뷰 상태 복원시 실행될 여지가 있는 리스너들은 onStart쪽에서 달아서 뷰 상태를 복구할때 의도치 않은 실행을 막아야 한다.

만약 뷰 상태와 관련없는 리스너라면(단순한 클릭 리스너 같은),  onViewCreated 쪽에서 해줘도 된다.

⇒ 따라서, 뷰 상태와 관련된 리스너인 TextWatcher나 onCheckedChangedListener 는 조심해야 한다.

TextWatcher의 메소드는 총 세개다. 이전, 바뀔때(여기서도 사용자의 입력으로 바뀐 값을 인자로 받는다), 바뀐 후

# 액티비티에서 프래그먼트를 호스팅 해주기

프래그먼트를 언제 액티비티에 추가할 것인지,  그리고 이후에 어떻게 할 것인지는 우리가 선택한다.

FrameLayout 과  FragmentContainerView 이 두 개가 프래그먼트를 호스팅 해주기 위해 액티비티가 제공하는 컨테이너 뷰가 될 수 있다.

프래그먼트가 등장하면서, 액티비티는 프래그먼트 매니저를 갖게 되었다.

**프래그먼트 매니저는 프래그먼트들(프래그먼트 리스트)와 프래그먼트 트랜잭션의 백 스택(프래그먼트 트랜잭션의 리스트)을 처리한다.**

프래그먼트 매니저는 **프래그먼트의 뷰를 액티비티의 뷰 계층에 추가**하고, **프래그먼트의 생명주기를 주도**하는 책임을 갖는다.

잡담) 프래그먼트 매니저를 호출하기 위해서는 supportFragmentManager를 호출해야 한다

이때 서포트 라는 용어는 v4 지원 라이브러리에서 유래한 것을, 제트팩으로 넘어온 이후에도 계속 사용하고 있는 것이라고 한다.

### 프래그먼트 트랜잭션

프래그먼트 트랜잭션을 생성하고 커밋해야 한다

프래그먼트 트랜잭션은 프래그먼트 매니저가 참조하는 프래그먼트 리스트에 프래그먼트를 추가, 삭제, 첨부, 분리, 변경 하는 데 사용된다.

**프래그먼트 매니저는 프래그먼트 트랜잭션의 백 스택을 유지 관리한다.**

트랜잭션이 백스택에서 제거될 때. 이 트랜잭션 연산들이 역으로 실행된다.

참고: 프래그먼트 트랜잭션은 ‘플루언트 인터페이스’를 사용한다고 한다. 이는 코드를 이해하기 쉽게 해주는 객체지향적인 기법으로 함수의 연쇄 호출 방식으로 구현된다도 한다.

⇒ 대충, 프래그먼트 트랜잭션이 호출하는 메소드들은 자신을 다시 반환하기 때문에 연쇄 호출이 가능하다는 의미

참고: 코틀린의 Unit은 하나의 인스턴스만 생성되는 싱글톤 객체다.

컨테이너 뷰 id는 프래그먼트 매니저의 프래그먼트 리스트에서 프래그먼트를 고유하게 식별하는 데도 사용될 수 있다?? ⇒ 그러면, 한 컨테이너 뷰 안에 여러 개의 프래그먼트가 있으면 얘네는 어떻게 구분되는거지? 가장 앞에있는 놈이 먼저 검색되나?(애초에 설계할 때 한 프래그먼트당 한 컨테이너 뷰가 함께 만들어지는걸 기대하고,  프래그먼트 매니저가 설계된듯함)

# 프래그먼트 매니저와 프래그먼트의 생명주기

프래그먼트 생명주기는 **중단, 일시 중지, 실행재개** 상태를 갖는다

프래그먼트의 생명주기 함수는 안드로이드 운영체제가 아닌 호스팅 액티비티의 프래그먼트 매니저가 호출한다.

안드로이드 운영체제는 액티비티가 사용하는 프래그먼트에 관해서는 아무것도 모른다고 한다… 정말???

프래그먼트 생명주기 순서

onAttach, onCreate, onCreateView, onViewCreated

onActivityCreated

onStart

onResume

onPause

onStop

onDestroyView, onDetach

<img width="663" alt="image" src="https://github.com/woowacourse/android-shopping-order/assets/67176829/d97e6319-01bf-475b-8485-66f6b6dfee2e">

onActivityCreated는 액티비티의 onCreate가 실행된 이후에 호출되는 것이 보장되는 함수다.

### 프래그먼트는 호스팅 액티비티의 생명주기를 따라간다.

만약 이미 액티비티가 재개상태인데 앱 실행중에 프래그먼트를 추가해본다면? 그 프래그먼트는 onResume까지 마친 액티비티의 생명주기 상태를 맞추기 위해 앞의 모든 메소드들을 실행하고 onResume까지 실행을 마칠 것이다.

일단 프래그먼트가 호스팅 액티비티의 상태를 따라잡으면 이후부터는 호스팅 액티비티의 상태와 동조된 프래그먼트 상태를 유지한다.

안드로이드 운영체제가 액티비티 생명주기 함수들이 호출되면 이것과 부합되는 프래그먼트 생명주기 함수들을 호출해준다.

# 이전 주제 복습) 유보 프래그먼트

유보 상태란? 액티비티로부터 분리되었고, 뷰는 파괴되었고, 인스턴스는 살아있는 상태를 말한다.

유보 상태는 아래 두 조건일 경우에만 가능하다

- retainInstance 값이 트루일때
- 구성변경으로 호스팅 액티비티가 소멸할 때

retainInstance 값이 트루로 설정된 프래그먼트들은 자신의 뷰만 소멸 시키고 자신은 그대로 유지한다.

회전에 의해 복구되는 경우에 유보 프래그먼트들은 새로 안만들어지고, 새롭게 만들어진 액티비티의 프래그먼트 매니저에게 넘겨지게 된다.

단,  유보 상태라고 하더라도 화면 회전시 뷰가 삭제되는 것은 동일함.

⇒ 만약 유보 상태가 아닌 프래그먼트들은 화면 회전 시, 뷰가 삭제되고 인스턴스도 제거된다. 그리고 새로운 액티비티의 프래그먼트 매니저가 그 프래그먼트 타입의 인스턴스들을 재생성한다.
