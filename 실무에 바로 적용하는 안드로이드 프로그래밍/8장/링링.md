# UI 프래그먼트와 프래그먼트 매니저

## UI 유연성의 필요

UI 유연성이란 사용자나 장치가 요구하는 것에 따라 런타임 시에 액티비티의 뷰를 구성하거나 변경할 수 있는 능력이다. 
그런데 액티비티는 이런 유연성을 제공하도록 설계되지 않았다. 
액티비티의 뷰들은 런타임 시에 변경되며, 이 뷰들을 제어하는 코드는 액티비티 내부에 있어야 한다. 
따라서 액티비티는 사용하는 특정 화면과 강하게 결합되어 있다. 

</br>

## 프래그먼트 개요

하나 이상의 fragment로 앱의 UI를 관리하면 유연성이 좋아진다. 
프래그먼트는 액티비티의 작업 수행을 대행할 수 있는 **컨트롤러 객체**다. 
여기서 작업이란 UI 관리를 말하여 UI 화면 전체 또는 일부분이 될 수 있다. 

액티비티 뷰는 자신의 UI를 갖는 대신 프래그먼트를 넣을 **컨테이너**를 가지며, 이 컨테이너에는 인플레이트 된 프래그먼트의 뷰가 추가된다. 
액티비티는 여러 개의 다른 프래그먼트 뷰를 수용하는 다수의 컨테이너를 가질 수 있다.

</br>

액티비티는 자신의 뷰 계층 구조에 프래그먼트와 그 뷰를 포함하는 곳을 제공하는데, 이것을 **호스팅**이라고 생각하면 된다. 
프래그먼트는 화면에 보이는 뷰를 자체적으로 가질 수 없으며, 액티비티의 뷰 계층에 추가될 때만 화면에 자신의 뷰가 보인다.

</br>

fragment의 생명주기 함수들은 프래그먼트를 호스팅하는 액티비티에서 자동 호출된다.

프래그먼트의 인스턴스는 `onCreate` 에서, 프래그먼트의 뷰는 `onCreateView` 에서 생성하고 구성한다. 
`onCreateView`에서는 프래그먼트 뷰의 레이아웃을 인플레이트 한 후 인플레이트된 View를 호스팅 액티비티에 반환해야 한다.

```kotlin
override fun onCreateView(
    inflater: LayoutInflater,
    container: ViewGroup?,
    savedInstanceState: Bundle?
): View? {
    return inflater.inflate(R.layout.fragment_crime, container, false)
}
```

`onCreateView` 함수의 각 인자들은 다음과 같다. 
1. 레이아웃 리소스 ID를 인자로 전달해  LayoutInflator.inflae를 호출하여 프래그먼트의 뷰를 명시적으로 인플레이트 한다.
2. 위젯들을 올바르게 구성하는 데 필요한 뷰의 부모
3. 인플레이트 된 뷰를 뷰의 부모에게 즉시 추가할 것인지를 LayoutInflater에게 알려준다.

</br>

### 프래그먼트에 위젯 연결하기

activity의 findViewById는 함수 내부적으로 View.findViewById()를 호출하는 편의 함수다. 
fragment에는 이런 편의 함수가 없으므로 직접 호출한다.

🤔 데이터 입력에 반응하는 listner들을 onStart에서 구현하는 이유

사용자와 뷰가 상호 작용할 때뿐만 아니라 장치 회전 등으로 인해 뷰 상태가 복원되면서 데이터가 설정될 때도 작동되는 리스너가 있기 때문

반면 onCLickListner들은 사용자와 상호 작용할 떄만 반응하므로 뷰에 데이터를 설정하는 것에는 영향을 받지 않는다. 
→ 리스너 설정을 onCreate에서 해도 된다.

</br>

## UI Fragment의 호스팅

UI 프래그먼트를 호스팅 하려면 액티비티는 다음 두 가지를 수행해야 한다. 

- 액티비티의 레이아웃에 프래그먼트의 뷰를 배치할 곳을 정의해야한다.
- 프래그먼트 인스턴스의 생명주기를 관리해야한다.

</br>

## FragmentManager에 UI 프래그먼트 추가하기

Fragment Manager는 **프래그먼트 리스트**와 **프래그먼트 트랜잭션의 백 스택**을 처리한다.
Fragment Manager는 프래그먼트의 뷰를 액티비티의 뷰 계층에 추가하고 프래그먼트의 생명주기를 주도하는 책임을 갖는다.

</br>

### Fragment transction 프래그먼트 트랜잭션

```kotlin
supportFragmentManager
    .beginTransaction()
    .add(R.id.fragment_container, fragment)
    .commit()
```

위 코드는 fragment 트랜잭션을 생성하고 커밋한다. 

프래그먼트 트랜잭션은 프래그먼트 리스트에 프래그먼트를 추가, 삭제, 첨부, 분리, 변경 하는데 사용된다. 
프래그먼트 트랜잭션을 사용하면 여러개의 오퍼레이션을 묶어서 수행할 수 있다. 
**프래그먼트로 런타임 시에 화면을 구성 또는 변경하는 방법의 핵심이 바로 프래그먼트 트랜잭션이다.** 

Fragment Manager는 프래그먼트 트랜잭션의 백 스택을 유지 관리한다. 
따라서 프래그먼트 트랜잭션이 다수의 오퍼레이션을 포함한다면 해당 트랜잭션이 백 스택에서 제거될 때 이 오퍼레이션들이 역으로 실행된다.
그러므로 다수의 프래그먼트 오퍼레이션들을 하나의 트랜잭션으로 묶으면 UI상태를 더욱 잘 제어할 수 있다. 

`beginTransaction` 함수는 FragmentTransaction의 인스턴스를 생성해 반환한다. 

FragmentTransaction 클래스는 플루언트 인터페이 (fluent interface)를 사용한다. 
즉, FragmentTransaction을 구성하는 함수들이 Unit 대신 FragmentTransaction 객체를 반환하기 때문에 이 함수들은 연쇄 호출 할 수 있다. 

</br>

컨테이너 뷰 ID는 다음 두 목적으로 사용된다.

- 액티비티 뷰의 어느 위치에 프래그먼트 뷰가 나타나야 하는지를 FragmentMager에 알려준다.
- FragmentManager의 리스트에서 프래그먼트를 고유하게 식별하는데 사용한다.

</br>

🤔 왜 요청한 프래그먼트가 어째서 이미 프래그먼트 리스트에 있을까?

여러 이유로 액티비티가 소멸되었다가 다시 생성될 때를 대비해서 리스트에 보존하기 때문!
장치 회전이나 안드로이드 운영체제의 메모리 회수 등..

</br>

### FragmentManager와 프래그먼트 생명주기

액티비티와 프래그먼트의 생명주기 함수가 대응된다는 점이 중요하다. 

프래그먼트는 액티비티를 대신해 작동하므로 프래그먼트의 상태는 액티비티의 상태를 반영해야 한다. 
따라서 프래그먼트는 액티비티의 작업을 처리하기 위해 액티비티와 일치하는 생명주기 함수가 필요하다. 

프래그먼트 생명주기와 액티비티 생명주기가 다른 점은 프래그먼트 생명주기 함수는 안드로이드 운영체제가 아닌 호스팅 액티비티의 FragmentManager가 호출한다는 점이다. 
프래그먼트는 액티비티가 내부적으로 처리해서 안드로이드 운영체제는 액티비티가 사용하는 프래그먼트에 관해서는 아무것도 모른다. 

`onAttach` , `onCreate` , `onCreateView` , `onViewCreated` 함수들은 프래그먼트를 FragmentManager에 추가할 때 호출된다. 

액티비티가 이미 실행 중일 때 프래그먼트를 추가하면 어떻게 될까? 이 때 FragmentManager는 해당 프래그먼트가 호스팅 액티비티의 상태를 따라잡는 데 필요한 프래그먼트 생명주기 함수를 몇 개이든 차례대로 즉시 호출한다. 일단 프래그먼트의 상태가 액티비티의 상태를 따라잡으면 이후부터는 호스팅 액티비티의 FragmentManager 액티비티 상태와 동조된 프래그먼트 상태를 유지한다. 

</br>

## 프래그먼트를 사용하는 애플리케이션 아키텍처

프래그먼트는 주요 컴포넌트를 재사용하게끔 캡슐화한다. 

만일 한번에 많은 프래그먼트를 화면에 넣는다면, 프래그먼트 트랜잭션 때문에 코드가 지저분하게 된다. 
따라서 작은 컴포넌트들을 재사용할 때는 프래그먼트 대신 커스텀 뷰로 추출하는 것이 좋은 방법이다. 
(일반적으로 한 화면에는 최대 2-3개 정도의 프래그먼트를 사용하는 것이 좋다고 한다.)
