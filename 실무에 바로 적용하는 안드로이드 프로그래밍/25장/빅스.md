# Chapter 25. Looper, Handler, HandlerThread



일단 책의 내용이 이전 코드가 이어지는 형태라 처음에 좀 당황했다.

또 아직 제대로 공부하지 않은 뷰모델, 라이브데이터에 대한 언급도 나와 당황했지만 중요하게 다루진 않아 읽을 수 있었다.

<br>

### @WorkerThread

> Denotes that the annotated method should only be called on a worker thread. If the annotated element is a class, then all methods in the class should be called on a worker thread.
>
> 어노테이션이 달린 메서드가 워커 스레드에서만 호출되어야 함을 나타냅니다. 주석이 달린 요소가 클래스인 경우 클래스의 모든 메서드는 워커 스레드에서 호출되어야 합니다.

위 어노테이션은 해당 메서드가 워커 스레드에서 동작해야한다고 알려줄 뿐 실제로 워커 스레드에서 동작 시켜주지는 않는다. 우리가 직접 동작시켜야한다.

<br><br><br>

## 백그라운드 스레드 만들기

<br>

* HandlerThread 상속 받기 - quit 메서드 오버라이드

<br>

### 생명주기 인식 스레드 만들기

#### retain `Fragment`

우리가 만드는 스레드는 네트워크 통신으로 이미지를 내려받기 위함이다.

이 백그라운드 스레드는 사용자가 인식하는 프레그먼트의 생애와 일치해야한다. (즉, 구성 변경에도 소멸되지 않고 보존되어야 한다)

`ViewModel`은 우리가 원하는 생애(사용자가 인식하는)를 갖지만 `ViewModel`에서 스레드를 관리하는 구현이 복잡하다(책에서 그렇다고 한다. 이 부분은 나도 잘 모르겠다) 

그래서 `Fragment`의 `retainInstance = true`를 통해 구성변경에도 프레그먼트가 죽지 않고 존재하게 한다. 즉 프레그먼트를 뷰모델의 생명주기로 사용한다. 

*(`AAC ViewModel`이 나오기 이전에 구성 변경으로부터 데이터를 지키기 위해 사용되었다. `API LEVEL 28`에서 `Deprecate` 되었다. 현재는 `AAC ViewModel`을 사용하면 된다.)*

> Control whether a fragment instance is retained across Activity re-creation (such as from a configuration change). This can only be used with fragments not in the back stack. If set, the fragment lifecycle will be slightly different when an activity is recreated:
>
> - `onDestroy()` will not be called (but `onDetach()` still will be, because the fragment is being detached from its current activity).
> - `onCreate(android.os.Bundle)` will not be called since the fragment is not being re-created.
> - `onAttach(android.app.Activity)` and `onActivityCreated(android.os.Bundle)` **will** still be called.
>
>
> 액티비티 재생성(예: 구성 변경)에서 프레그먼트 인스턴스가 유지되는지 여부를 제어합니다. 이 옵션은 백 스택에 없는 프레그먼트에만 사용할 수 있습니다. 이 옵션을 설정하면 액티비티가 다시 만들어질 때 프레그먼트 수명 주기가 약간 달라집니다:
>
> * 프레그먼트가 현재 액티비티에서 분리되고 있기 때문에 onDestroy()가 호출되지 않습니다(하지만 onDetach()는 여전히 호출됩니다).
>
> * 프레그먼트가 다시 생성되지 않으므로 onCreate(android.os.Bundle)는 호출되지 않습니다.
>
> * onAttach(android.app.Activity) 및 onActivityCreated(android.os.Bundle)는 계속 호출됩니다.

<br><br>

#### `LifecycleObserver` 인터페이스 구현하기

* `@OnLifeCycleEvent(Lifecycle.Event.ON_CREATE)` 어노테이션을 통해 생명주기 콜백 호출을 받을 수 있다.
* but 해당 어노테이션은 `deprecate` 되었으므로 `DefaultLifecycleObserver` 혹은 `LifecycleEventObserver` 인터페이스를 구현하도록 하자. 둘의 차이는 아직 모르겠으며 전자와 후자가 공존할 경우 전자의 메서드가 먼저 호출된다. 본인은 전자를 사용해보았다.

![OnLifecycleEvent annotation Deprecated](C:\Users\brian\AndroidStudioProjects\woowacourse\realCourse\2023-fun-readBook-AN\실무에 바로 적용하는 안드로이드 프로그래밍\25장\OnLifecycleEvent annotation Deprecated.png)

> DefaultLifecycleObserver 공식문서 중..
>
> 
>
> Callback interface for listening to `LifecycleOwner` state changes. If a class implements both this interface and `LifecycleEventObserver`, then methods of `DefaultLifecycleObserver` will be called first, and then followed by the call of `LifecycleEventObserver.onStateChanged`
>
> If a class implements this interface and in the same time uses `OnLifecycleEvent`, then annotations will be ignored.
>
> 
>
> 라이프사이클 오너 상태 변경을 수신하기 위한 콜백 인터페이스입니다. 클래스가 이 인터페이스와 LifecycleEventObserver를 모두 구현하는 경우, DefaultLifecycleObserver의 메서드가 먼저 호출되고 그 다음에 LifecycleEventObserver.onStateChanged의 호출이 이어집니다.
>
> 클래스가 이 인터페이스를 구현하면서 동시에 OnLifecycleEvent를 사용하는 경우, 어노테이션은 무시됩니다.

[OnLifecycleEvent 공식문서](https://developer.android.com/reference/androidx/lifecycle/OnLifecycleEvent)

[DefaultLifecycleObserver 공식문서](https://developer.android.com/reference/androidx/lifecycle/DefaultLifecycleObserver)

[LifecycleEventObserver 공식문서](https://developer.android.com/reference/androidx/lifecycle/LifecycleEventObserver)

<br>

`Fragment`에서 우리의 `Downloader`를 생성하고 `onCreate`에서 `lifecycle.addObserver(downloader)`와 같이 라이프 사이클을 추가해준다. (`onDestroy`에서 `lifecycle.removeObserver(downloader)`를 통해 해제해준다.)

<br><br><br>

