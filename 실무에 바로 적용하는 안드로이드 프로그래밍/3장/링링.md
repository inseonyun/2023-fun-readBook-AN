# 액티비티 생명주기

## 액티비티의 4가지 상태 

### 존재하지 않음 (nonexistent)

액티비티가 아직 론칭되지 않았거나 소멸된 상태. 
액티비티 인스턴스는 메모리에 존재하지 않고, 사용자가 보거나 상호작용하기 위한 뷰도 없다.
예: 백버튼

</br>

### 중단 (stopped)

액티비티 인스턴스가 메모리에 있지만, 뷰는 화면에서 볼 수 없다.
액티비티가 처음 시작될 때 거쳐가는 상태로, 액티비티 인스턴스의 뷰가 화면에서 완전히 가려졌을 때 언제든 다시 집입하는 상태
예: 홈버튼

</br>

### 일시중지 (paused)

액티비티가 포그라운드에서 작동하지는 않지만, 액티비티의 인스턴스 뷰 전체 또는 일부를 화면에서 볼 수 있다. 
예) 액티비티 위에 새로운 대화상자나 투명 액티비티가 사용자에 의해 시작 → 일부만 화면에 노출,
다중 창 모드 → 액티비티 전체가 화면에 보이지만, 포그라운드에 존재하지 않을수도 있다.

</br>

### 실행 재개 (resumed)

현재 상호작용하고 있는 액티비티의 상태
실행 재개 상태는 장치의 전체 시스템에 걸쳐 하나의 액티비티만 될 수 있다. 

</br>

→ 함수들을 이용해 액티비티 생명주기의 전환 시점에 필요한 일을 처리할 수 있다. 
: **생명주기 콜백(lifecycle callback)**

</br>

## 생명주기 콜백

| 각 함수에 override 키워드가 있는 이유? 
오버라이드하는 함수가 슈퍼클래스에 있는지 컴파일러에게 확인하라고 요청하기 위해서다. 
override 키워드를 사용하면 오타로 인한 에러 발생을 런타임이 아닌 컴파일 시점에 방지할 수 있다.

</br>

### 실행
onCreate-onStart-onResume이 모두 호출된 후에 MainActivity 인스턴스가 생성된다.

</br>

### 홈버튼
‘다른 작업을 하려고 하지만, 다시 돌아올 수 도 있다.’ → 중단 상태
onPause-onStop

</br>

### 오버뷰 화면에서 앱 선택하여 들어옴
onStart-onResume
MainActivity 인스턴스는 여전히 메모리에 있으므로 다시 생성될 필요가 없다.

</br>

### 백버튼
onPause-onStop-onDestroy (난 왜onDestroy 안불리지)
onDestroy가 불린이후에는 인스턴스가 메모리에도 없고 화면에도 보이지 않고 포그라운드에서도 동작하지 않는다. 
안드로이드 운영체제는 해당 액티비티를 소멸시키고 메모리로부터 모든 흔적을 지운다. 
이것이 바로 장치의 제한된 리소스를 절약하는 안드로이드의 방식이다.

</br>

### 다중창 모드
안드로이드7.0 누가 이상에서 사용 가능.
onPause-onStop-onDestroy-onCreate-onStart-onResume ? 이게 맞아?

</br>

### 화면 회전
onPause-onStop-onDestroy-onCreate-onStart-onResume
화면 회전을 하게 되면 MainActivity 인스턴스는 완전히 소멸된다.

</br>

## 장치 구성 변경과 액티비티 생명주기

### 장치 구성 (device configuration)

장치를 회전하면 장치 구성이 변경된다. 장치 구성은 현재 상태를 나타내는 특성들의 집합이다.
: 화면 방향, 화면 밀도, 화면 크기, 키보드 타입, 도크 모드, 언어 등

</br>

### 런타임 구성 변경 (runtime configuration change)

런타임 구성 변경이 생길 때는 새로운 구성에 더 잘 맞는 리소스들이 있을 수 있다. 
따라서 안드로이드는 현재의 액티비티 인스턴스를 소멸시키고 새로운 구성에 가장 적합한 리소스를 찾는다.

</br>

### UI 변경과 다중 창 모드

안드로이드 7.0 이전에는 대부분의 액티비티가 매우 짧은 시간동안만 ‘일시중지’ 상태에 머물렀다가 곧바로 ‘실행 재개’ 상태나 ‘중단’ 상태로 바뀌었다. 

→ 이 때문에 액티비티의 상태가 ‘일시중지’가 아닌 ‘실행재개’일 때 UI를 변경해야한다고 생각하는 개발자들이 많아서 UI 관련 진행 중인 변경의 시작과 중단을 onResume과 onPause에서 하는 것이 일반적이었다. 

하지만, 다중창이 생기면서 일시 중지의 상태인 액티비티가 화면에 긴 시간 노출될 수 있었고, 사용자들은 일시 중지의 액티비티가 실행중이라고 생각할 수 있다. 

예) onResume에서 비디오 재생, onPause에서 중지 하는 비디오 앱 (안드로이드 7.0 이전)이 있다고 해보자. 다중 창 모드에서 사용자가 다른 창의 앱을 사용하면 비디오 앱은 멈추게 된다. onPause가 되니까. → 이 문제는 비교적 간단한데, onStart에서 비디오 재생, onStop에서 비지오 중단하면 된다.

아무튼, 안드로이드 7.0 이후에는 액티비티를 화면에 볼 수 있는 onStart부터 onStop까지의 전체 생명주기 동안에 UI를 변경해야한다. 
하지만, 여전히 많은 앱들이 다중창 모드에서 제대로 작동하지 못했고, 이에 구글 안드로이드 팀은 **다중 실행 재개(multu-resume)** 지원 사양을 내놓았다. 

→ 다중 창 모드의 장치에서 사용자가 어떤 창의 앱을 사용하건 각 창에 완전하게 보이는 액티비티들이 실행 재개 상태가 된다.
안드로이드 9.0 파이 이상에서 앱이 실행될 때는 메니페스트 파일에 `<meta-data android:name="android.allow_multiple_resumed_activities" android:value="true" />를 추가해 다중 실행 재개 모드를 사용가능하다.