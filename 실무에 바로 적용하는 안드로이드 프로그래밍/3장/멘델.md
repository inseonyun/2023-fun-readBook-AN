# 2. 액티비티 생명주기

액티비티에는 총 네 개의 상태가 있다고 한다.

1. 실행 재개 2. 일시중지 3. 중단 4. 존재하지 않음

### 액티비티 상태 다이어그램

<img width="684" alt="image" src="https://github.com/woowacourse-study/2023-fun-readBook-AN/assets/67176829/18f7c730-3088-42d1-88d1-35ca96a25c88">

이 그림을 보고 신기했다.

onCreate 이후와 onStop 이후의 상태가 ‘중단’으로 같다는 것이다.

onStart 이후 일시 중지 상태가 된다.

그런데, 일시 중지 상태는 사용자에게 부분적으로 보일수도 있는 상태이다(그 때 상황에 따라 다르다).

onResume 이후에서야 실행 재개 상태가 된다.

실행 재개 상태가 되어야 포그라운드에서 실행중이라고 말을 한다.

액티비티 상태는 총 네 가지이고, **메모리 존재 여부, 가시성 여부, 포그라운드 실행 여부**

이 세가지에 따라 나뉜다.

## 중단 상태

onCreate이후 혹은 onStop이후의 중단 상태에 위치한 액티비티는 화면에서 보이지 않는다. 이 상태로 들어가기 위해서는 다음과 같은 시나리오들이 있다.

1. 액티비티가 처음 시작될때
2. 액티비티가 화면에서 가려져서 아예 안보일때 ⇒ 즉, 액티비티는 언제든지 중단 상태로 다시 들어갈 수 있다.

   참고: 중단 상태에 있다가 다시 포그라운드로 돌아가야 할때, onRestart를 실행한 다음에 onStart를 실행하고 onResume을 실행해서 다시 실행 재개 상태로 돌아간다.


## 일시 중지

액티비티가 포그라운드에서 작동은 하지 않지만(사용자와 상호작용이 안되는 상태), 일부라도 보이기는 할때

(onPause이후 일시 정지 상태에서, 전체화면이 보일 수도 있다고 한다. 예를 들어 다중화면일때 포커스가 벗어난 창들은 일시 중지 상태에 들어가게 되는 듯함)

⇒ 말에 살짝 오류가 있는듯? onStart 이후에도 onResume을 마치지 않는다면, 해당 액티비티 인스턴스의 뷰가 전혀 보이지 않는다.

## 실행 재개

실행 재개 상태는 액티비티가 사용자와 상호작용하고 있음을 의미한다.

실행 재개 상태의 액티비티는 장치의 전체 시스템에 걸쳐서 하나의 액티비티만 가능하다.

즉, 한 액티비티가 실행 재개 상태가 되었다는 것은 다른 액티비티는 일시 중지 상태 그 이하로 내려갔다는 것이다.

## 참고

onResume 을 마쳐야 우리가 인플레이팅한 레아웃 뷰가 보이기 시작한다.

# 생명주기 콜백

생명주기 상태가 변경되기 전, 전환시점에 필요한 일을 처리할 수 있도록 해주는 함수들이다.

### onCreate

1. setContentView를 실행해야 한다. 이를 통해서 인플레이팅한 뷰 객체를 화면에 보여준다.
2. 리스너를 설정하는 단계
3. 모델 데이터를 활용해서 뷰에 보일 데이터 값들을 초기화한다.

## 우리가 생명주기 콜백을 실행하지 않는다.

## 액티비티의 상태가 변경되어야 할때, 안드로이드가 액티비티에게 ‘너 이제 상태 변경될거야~ 그전에 하고 싶은 일들 해’ 라고 알려주기 위해 이 콜백함수를 적절한 시점에 호출한다.

# 로그메시지와 LogCat

LogCat은 안스 하단에 위치한 로그캣 도구 버튼이라고 한다.

로그캣에는 시스템의 모든 메시지가 출력된다.

android.util.Log 클래스

1. 공유되는 시스템 수준의 로그에 로그메시지를 전달해주는 클래스. 로그메시지를 전달하기 위한 메소드로는 대표적으로 d가 있다. d는 디버그를 의미한다.

   함수 선언은 이처럼 한다: d(스트링 tag, 스트링 msg)

   이런 d와 같은 것들을 **로그 메시지 레벨** 이라고 한다.

<img width="679" alt="image" src="https://github.com/woowacourse-study/2023-fun-readBook-AN/assets/67176829/753b5d1e-00dc-411d-9a99-0904f71897e9">


   ⇒ 이처럼, level:debug 를 사용해서 로그 메시지 레벨을 지정가능하다.


# 최상위 수준 속성

어떤 클래스에도 선언되지 않고 파일의 취상위 위치에 선언된 변수나 함수를 말한다.

이런게 원래는 자바에서 **-유틸** 이라는 접미사가 붙은 이름의 클래스로 스태틱 멤버로 들어가 있었다고 한다.

때문에, 실제로 코틀린에서 이런 최상위 수준 속성이나 함수를 디컴파일 해보면 자바의 별도의 클래스의 스태틱 요소로 들어가게 된다고 한다.

# 오버라이드 키워드의 존재이유

⇒ 컴파일러에게 이 메소드가 진짜 슈퍼에게 존재하는 메소드인지 확인받기 위해. 컴파일러 수준에서 체크할 수 있게 된다.

# 다시 생명주기로 돌아가서

중단 상태의 앱은 언제든지 시스템의 판단하에 메모리가 부족하다면 제거가 가능하다. 4장에서 자세히 다룬다고 한다

### 오버뷰 화면  (= 최근 앱 화면 or 태스크 매니저)

⇒ 태스크 목록을 확인 가능한 화면

오버뷰 화면의 각 카드는 이전에 사용자가 사용한 앱들이다.

# 다중 창 모드란?

안드로이드 7 누가 이후에 나왔다고 한다.

오버뷰 화면에서 카드를 꾹 누르면 다중창 모드로 열 수 있다.

다중 창 모드에서도 “실행 재개 상태인 액티비티는 단 한개뿐” 이라는 조건이 성립한다. 포커스가 주어진 액티비티를 제외하고는 모두 onPause 실행 이후 일시 정지 상태가 된다.

# 액티비티 종료

**뒤로가기** or **finish()호출**

# 액티비티 회전

액티비티 인스턴스는 회전시마다 완전히 소멸된다. 때문에 액티비티가 참조하고 있던 변수들에 대한 참조를 모두 잃게 된다. 이런 참조를 다시 불러올 수는 없다. ⇒ 회전 시 생기는 결함 문제는 다음 4장에서 해결할 것임.

### 왜 회전하면 액티비티의 인스턴스가 소멸될까?

장치 회전을 하면, **장치 구성**이 변경된다.

장치 구성이란? 각 장치의 현재 상태를 나타내는 특성들의 집합

(화면 방향, 화면 밀도, 화면 크기, 키보드 타입, 도크 모드, 언어 등)

앱에는 이 장치 구성들이 바꿨을때 바뀐 장치 구성 요소에 따라 알맞은 리소스를 선택할 수 있도록 기능을 제공한다. ⇒ 실제로 이미지를 화면 밀도 별로 리소스를 준비한다면, 해당 디바이스의 장치구성요소인 화면 밀도에 따라 적절한 이미지 리소스를 선택한다.

### 만약 런타임에 구성이 변경된다면?

런타임에 변경되면, 기존보다 더 현재의 구성에 적절한 리소스가 존재할 수 있다.

따라서 장치 구성이 변경된다면, 새로운 구성에 더 잘 맞는 리소스들을 찾아서 앱을 재구성하기 위해

현재 액티비티의 인스턴스를 소멸시키고, 더 적절한 리소스들로 새로 만든다.

-land는 대표적인 구성 수식자 중 하나다.

## 프레임 레이아웃은 자식 뷰들을 배치하는 특별한 방법이 없는 뷰그룹이다.

# # UI변경과 다중 창 모드

누가 버전 이전의 안드로이드에서는 액티비티가 짧은 시간동안만  ‘일시 중지’ 상태에 머물렀다가 곧바로 실행 재개나 중단 상태로 바꿨다.

⇒ 이로인해, onPause에서는 별도의 큰 작업을 하면 안된다고 생각하는 개발자들이 많았다.

⇒ 때문에, UI와 관련해서 진행 중인 변경(애니메이션이나 데이터 갱신)의 시작과 중단을 onResume과 onPause에서 하는 것이 일반적이었다. 만약 onPause일때 애니메이션(비디오 영상도 포함)을 중단 시킨다면 다중 창 모드 출시 전까지(일시 중지 상태에 모든 전체 화면이 노출될 수가 없을 때)는 문제가 없었을 것이다.

### 다중 창 모드가 도입되면서, 일시 중지 상태인 액티비티가 오랜 시간동안 유저에게 전체화면이 보일 수 있게됐다. ⇒ 이로인해, 유저들은 해당 액티비티가 마치 아직 재개상태인 것처럼 느끼게 된다. 그런데!!!! onPause에서 영상을 정지시킨다면? 사용자는 다중창모드로 보이는 화면에서 다른 화면으로 포커스가 넘어가게 된다면 영상이 종료된 것처럼 보일 것이다.

⇒  onResume이 아닌 그 전인 onStart에서 비디오 재생 시작을, onPause가 아닌 onStop에서 비디오를 재생하도록 하면 다중 창 모드에서도 문제가 해결된다.

따라서, 안드로이드 7버전인 누가부터는

정지 상태 / onStart()~onStop() / 정지 상태

⇒ 액티비티를 화면에서 전체로 볼 가능성이 있는 이 범위 내내 ui 변경을 수행해도 된다.

하지만, 이 다중 모드 대응을 제대로 못한 앱들이 너무 많아서 구글이 대안책을 마련함.

2018년에 **다중 실행 재개** 지원 사양을 내놓았다. ⇒ 실행 재개 상태는 단 하나라는 규칙을 깰 수 있는 것.

안드로이드 9.0 파이 이상에서 앱이 실행될 때는 매니페스트 파일에 추가해야 한다.

# 로그 메시지 정복

e, w, i, d, v

try-catch 같은 걸로 잡은 예외에 대해서는 Log.e로 출력하는게 좋다.
