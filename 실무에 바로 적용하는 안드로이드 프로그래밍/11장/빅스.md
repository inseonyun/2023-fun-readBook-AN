Room은 API, 어노테이션, 컴파일러로 구성되어 있다.

* API : 데이터베이스를 정의하고 인스턴스를 생성하기 위해 상속받는 클래스들이 포함되어있다.
* 어노테이션 : 데이터베이스에 저장할 필요가 있는 클래스, 데이터베이스를 나타내는 클래스, 데이터베이스 테이블을 사용하는 함수들을 정의하는 클래스 등을 나타내기 위해 어노테이션을 사용한다.
* 컴파일러 : 지정한 어노테이션을 컴파일해서 데이터베이스 구현체를 생성한다.

<br>

_ _ _



### 플러그인과 의존성

kotlin-kapt 플러그인과 room-runtime, room-compiler 의존성을 추가했다.

<br>

**kotlin-kapt**는 코틀린 어노테이션 처리 도구(Kotlin annotation processor tool)이다.

라이브러리에서 생성한 클래스를 코드에서 직접 사용하고자 할 때가 있다. 그런데 기본적으로 라이브러리가 생성한 클래스들은 안드로이드 스튜디오에서 알 수가 없어 이런 클래스들을 import해서 사용하려고 하면 에러가 발생한다. kotlin-kapt 플러그인을 추가하면 라이브러리가 생성한 클래스들을 안드로이드 스튜디오에서 알 수 있으므로 import해서 사용할 수 있다.

<br>

**room-runtime** 의존성은 데이터베이스를 정의하는데 필요한 모든 클래스와 어노테이션을 포함하는 Room API다.

**room-compiler**는 지정한 어노테이션을 컴파일해서 데이터베이스 구현체를 생성한다. room-compiler 의존성을 지정할 때는 implementation 대신 kapt 키워드를 사용해 Room 컴파일러가 생성한 클래스들을 안드로이드 스튜디오가 알 수 있게 한다.

```groovy
plugins {
    id 'kotlin-kapt'
}
dependencies {
    implementation 'androidx.room:room-runtime:2.2.6'
    kapt 'androidx.room:room-compiler:2.2.6'
}
```

<br>

_ _ _



Room으로 데이터베이스를 생성할 때는 다음 세 단계로 한다.

* 모델 클래스에 어노테이션을 지정해 데이터베이스 엔티티로 만든다.
* 데이터베이스 자체를 나타내는 클래스를 생성한다.
* 데이터베이스가 모델 데이터를 처리할 수 있게 타입 변환기를 생성한다.

<br>

### 엔티티 정의하기

Room은 우리가 정의한 엔티티를 기반으로 앱의 데이터베이스 테이블 구조를 만든다.

@Entity 어노테이션은 클래스 수준에 적용된다.

이 엔티티 어노테이션은 해당 클래스가 데이터베이스 테이블의 구조를 정의함을 나타낸다.

@PrimaryKey 어노테이션은 기본키 열을 지정한다. 이 속성을 쿼리에 사용할 수 있다.

<br>

이렇게 쭉 정리하고 있었는데 뭔가 책을 나열하는 것 같고 내용이 너무 길어져서 이제 짧게 느낀점만 적겠다.

<br>

* SQLite

SQLite 얘기를 하면서 궁금했던 점이 있다. MySQL이나 PostgreSQL을 얘기하면서 "SQLite는 다른 데이터베이스와 달리 라이브러리를 사용해서 데이터를 읽거나 데이터를 쓸 수 있는 파일에 저장한다." 라고 적혀있다.

이때 다른 것들과 어떤 부분이 다르다는건지? 잘 모르겠었다.

<br>

* 타입 변환기

나는 SQLite를 사용할 때 디비에 저장하기 전에 저장할 수 있는 타입으로 미리 변환해서 저장해왔다.

그래서 Room에서도 같을 것이라고 생각했는데 이렇게 타입 변환기를 미리 만들어둘 수 있다는 것을 새로 알게 되었다.

<br>

* 왜 Repository를 싱글톤으로?

Repository가 아닌 Database만 싱글톤으로 만들면 되지 않나..? 왜 굳이 context를 Repository까지 거쳐서 받는 것인지 이해가 되지 않았다.

<br>

* 백그라운드 스레드는 대체 어디서?

책에서 룸은 메인 스레드에서 접근할 수 없다고 설명한다. 그러면서 백그라운드 스레드 얘기 한참 하더니 막상 코드에선 백그라운드 스레드를 사용하는 모습을 찾아볼 수가 없다.

<br>

* 왜 룸에선 라이브데이터를 반환하는가?

그냥 값을 반환하고 뷰모델에서 livedata.value = 반환값 이렇게 하면 될텐데 왜 룸에서 라이브데이터를 반환한걸까?
