# 14장 앱바

# 앱 바

사용자가 수행할 수 있는 액션과 화면 간을 이동할 수 있는 메커니즘을 제공

또한 화면 상단 부분의 디자인에 일관성을 줄 수 있음.

**⇒ 앱바는 액션 바 혹은 툴바와 비슷한 개념. 이 셋의 차이는 후반에 나옴.**

### 기본적으로 프로젝트에 따로 설정을 안하면, 기본 앱바가 제공된다

기본 앱바가 있는 이유: AppCompatActivity에 기본적으로 앱바를 제공하도록 설정되어 있다.

1. 기본적으로 프로젝트를 만들면 AppCompat 라이브러리가 의존성 추가되어있음.

   `implementation 'androidx.appcompat:appcompat:1.6.1'`

2. AppCompat테마(앱바가 포함되어있는) 중 하나가 적용되어있음.

### AppCompat

의미: application compatibility의 단축어

⇒ 안드로이드 버전이 달라도 일관된 UI를 유지하는 데 핵심이 되는 클래스와 리소스들을 포함하고 있음

### 안스 버전에 따른 기본 앱 전체 스타일

안스 버전에 따라서 스타일 리소스 파일에 정의되어있는 **앱 전체 기본 스타일**이 다르다고 한다.

- 안스 버전 4.1.1 이전 버전인 경우

  Theme.AppCompat.Light.DarkActionBar

- 안스 버전 4.1.1 이후 버전인 경우

  ![image](https://github.com/woowacourse-study/2023-fun-readBook-AN/assets/67176829/36cc35d4-ae7d-4002-9e50-9e92e1964597)

  ⇒ 4.1.1 이후 버전에서는 스타일 이름도 Theme.앱이름 으로 나온다.

  여기서는 Test라는 이름의 앱에 대한 앱 전체 기본 스타일이 지정된 내용임.


### 애플리케이션 테마는 매니페스트 파일의 애플리케이션 수준에 지정된다

![image](https://github.com/woowacourse-study/2023-fun-readBook-AN/assets/67176829/f78f9a76-df10-41e9-bd11-ad27d1ddfa86)

액티비티마다 별도로 지정할 수도 있다고 함 ⇒ 아직 직접 테스트 해보진 않음

# 앱 바의 메뉴란? (액션 메뉴)

앱 바의 오른쪽 상단부분에 메뉴를 넣을 수 있다. 이런 메뉴는 **action item**으로 구성된다

액션 항목: 현재 화면과 관련된 액션 또는 앱 전체의 액션을 수행할 수 있다.

액션 항목의 이름, 즉 스트링은 스트링 리소스에 만들어야 한다고함 ⇒ 강제인지는 모르겠음. 추후에 테스트하고 업데이트 할 예정

### xml로 메뉴 정의하기

메뉴는 레이아웃과 유사한 리소스임. **xml 파일로 생성해서 프로젝트의 res/menu 디렉터리 아래에 둬야 함.**

⇒ 리소스 타입을 Menu로 두고 리소스 파일을 하나 만들면 이 디렉터리 아래에 들어간다.

앱을 빌드하면, 해당 메뉴 파일의 리소스 id가 자동 생성된다. 이걸 활용해서, 코드에서 메뉴를 인플레이트 시킬 수 있다.

```xml
<menu >
	<item
		android:id = "@+id/아이디부여"
		android:icon = "@android:드로어블 리소스"
		android:title = "@string/액션항목의이름"
		app:showAsAction = "ifRoom|withText" />
</menu>
```

- showAsAction 속성
    - 액션 항목이 앱 바 자체에 보이게 할 것인지, 아니면 **오버플로 메뉴**(앱 바의 최우측에 세 개의 점으로 표현됨)에 포함되어 보이도록 할 것인지를 지정 가능하다.
        - **ifRoom|withText** 는 앱 바에 공간이 있으면 아이콘과 텍스트 모두 앱바에 보여주고, 둘 다 보여줄 공간이 없으면 해당 액션 항목은 오버플로 메뉴에 들어간다.
            - withText 가 있어야 title 속성에 설정한 값도 액션바에 같이 보인다.
        - **always** 액션항목을 항상 앱바에 보여주도록 하는 옵션 ⇒ 권장하지 않는 방법이라고 함.
            - ifRoom으로 운영체제에게 선택권을 주는 것이 더 유연한 방법이라고 한다
        - **never** 오버플로 메뉴에 위치 시키는 옵션 ⇒ 자주 사용하지 옵션인 경우에 오버플로 메뉴에 숨기는게 낫다
- menu 태그 안에 들어간 app 네임 스페이스는 AppCompat 라이브러리와 연관된 것을 사용할 때 필요하다고 함. showAsAction 속성을 정의하기 위해서는 app네임스페이스가 필요하다고. 그리고 이 네임스페이스의 구체적인 라이브러리를 지정하는 속성이 xmls임.
    - 이전 버전의 안드로이드와 호환되는 액션 바를 넣을 수 있게 해준다. → 액션 바를 지원하지 않는 안드로이드 버전을 실행하는 장치에서도 액션 바가 보일 수 있도록
    - app 네임스페이스를 별도로 우리가 지정해서 AppCompat 라이브러리에 포함된 showAsAction 속성을 사용하고 있다. 지금 안드로이드 내장 showAsAction 속성을 사용하고 있는 것이 아님.

# 메뉴를 만들고 각 액션 항목의 리스너를 연결하는 콜백함수들

이 함수는 액티비티에 있는데, 프래그먼트에서도 이 코드를 구현해서 호출할 수 있다고 함.

액티비티에서는 onCreateOptionsMenu(Menu) 라는 함수를 우리가 재정의하고,

프래그먼트에서는 onCreateOptionsMenu(Menu,MenuInflater) 라는 것을 재정의 해주면 됨.

각 액션 항목의 선택에 응답하는 함수의 경우는 onOptionsItemSelected(MenuItem)을 재정의 해주면 된다.

### 메뉴 리소스 인플레이트 하기

```kotlin
override fun onCreateOptionsMenu(menu:Menu, inflater:MenuInflater){
		super.onCreateOptionsMenu(menu,inflater) 
		// => 일단은 생략가능하다. 왜냐하면,프래그먼트의 이 슈퍼 함수에서는 아무 일도 안하므로
		
		inflater.inflate(R.menu.메뉴리소스파일ID, menu)
}
```

MenuInflater.inflate(메뉴파일 리소스 ID, Menu)

⇒ 파일에 정의된 액션 항목들로 Menu 인스턴스가 채워지게 된다.

## 프래그먼트의 onCreateOptionsMenu(Menu, MenuInflater)가 호출되는 시점

⇒ 액티비티가 운영체제로부터 onCreateOptionsMenu 콜백함수 호출을 받았을 때, 프래그먼트 매니저가 현재 보이는 프래그먼트의  onCreateOptionsMenu(Menu, MenuInflater)를 호출하는 책임을 갖는다고 함.

때문에, 프래그먼트 매니저는 이 프래그먼트가 해당 콜백 함수를 오버라이드한 녀석인지 알아야 함. 그래야 앱 바를 재구성할지 알 수 있기 때문

⇒ 그래서, 앱 바 재구성이 필요한 프래그먼트는 setHasOptionsMenu(hasMenu:Boolean) 을 onCreate 생명주기 콜백에서 호출해야 함. 그래야 프래그먼트 매니저에게 “나 이 콜백 함수 호출해줘” 라고 알려주는 것이 된다.

### 세로 방향일때는 보통은 아이콘 보여줄 공간밖에 없다

앱 바의 아이콘을 길게 누르면 텍스트를 볼 수 있다고 함

# 메뉴 선택에 응답하기

메뉴 항목을 누르면, 프래그먼트에서 onOptionsItemSelected(MenuItem) 함수의 콜백 호출을 받게 된다고 함. 여기서 인자로 사용자가 선택한 MenuItem 인스턴스를 받는다고 함.

어떤 액션 항목이 선택되었는지, 코드 상에서는 해당 MenuItem의 ID를 확인해서 알아내야 한다고 함.

**이 함수에서는 정상적으로 처리가 끝났다면 끝났다고 Boolean을 반환해줘야 한다.**

# 애뮬레이터에서 한글 사용하는 법

페이지 316에 나옴.

# 안드로이드 애셋 스튜디오 사용하기

시스템 아이콘이란? 프로젝트의 리소스에 포함된 것이 아니라, 장치 자체에 있는 아이콘을 말한다.

시스템 아이콘을 활용해도 무방하나, 시스템 아이콘은 장치나 안드 버전 따라 차이가 있을 수 있음.

- 자체 아이콘을 만들고 싶다면, 안드로이드 아이콘 디자인 지침 페이지인 아래 링크를 따르자.

https://m2.material.io/design/iconography/product-icons.html#design-principles

- 시스템 자체 아이콘에 어떤것이 있는지 확인하고 싶다면?

안드로이드 SDK가 설치된 디렉토리를 찾는다. 그리고 **그 아래의 platforms/android-XX/data/res 에 있다.**

- 안스에 포함된 안드로이드 애셋 스튜디오를 사용하는 방법도 있다. 애셋 스튜디오를 사용하면, 앱 바에 사용할 이미지를 쉽게 얻고 커스터마이징 가능하다.

  이때, 애셋 타입은 Clip Art로 하고, 테마는 HOLO DARK 로 한다. 이 테마로 클립아트를 얻으면 앱바가 어두우면, 이미지가 밝게 나타난다.

  애셋 스튜디오가 만들어주는 아이콘은 xml 파일 한 개와, 해상도 별 존재하는 PNG 파일들로 구성된다.


# 궁긍즘 해소: 앱 바 vs 액션 바 vs 툴바

일단 이 셋은 모두 조금씩 다르나 공식문서에서도 혼용해서 사용하고 있음.

UI 설계 요소로는 앱 바 라고 부르는 것이 맞다고 함.

안드로이드 5.0 이전에는 앱 바를 액션바 클래스로 구현되었기에 둘이 같은 걸로 간주했음.

하지만, 5.0부터 툴바라는 클래스로도 앱바를 만들 수 있게되면서 용어가 헷갈리기 시작했다고 함.

### **2021년 기준으로 AppCompat 라이브러리는 제트팩에 존재하는 Toolbar 위젯을 사용해서 앱 바를 구현한다고 함.**

### 액션바와 툴바의 차이

액션바는 항상 화면의 최상단에 나타나며, 한 화면에 한 개만 존재 가능하다는 제약이 있음.

액션바는 크기도 고정적으로 바꿀 수 없다.

⇒ 툴바는 이런 제약이 없다.

툴바는 내부에 다른 뷰도 둘 수 있고 높이 조절 등 모두 되며, 액티비티나 프래그먼트의 레이아웃 파일에 툴바뷰를 포함시킬 수 있다.

# 궁긍즘 해소하기: AppCompat 앱 바 사용하기

AppCompat 라이브러리의 앱 바를 사용하려면 AppCompatActivity의 supportActionBar 속성을 참조하면 된다.

```kotlin
	val appBar = supportActionBar as Toolbar
	appBar.setTitle(리소스ID 지정 가능)
```

### 강조: AppCompat 라이브러리는 Toolbar를 사용해서 앱 바를 구현함. 과거에 액션바를 사용해서 앱 바를 사용하는 속성명에 액션바가 포함된 것 뿐임.

## 런타임 중에 앱 바 메뉴 구성 내용을 변경하고 싶다면?

invalidateOptionsMenu() 함수를 호출하기. 이 함수는 액티비티가 가진 함수임.

그러면, 내부적으로 onCreateOptionsMenu를 호출한다. 여기서 분기문으로 상태에 따라 다른 메뉴를 보이도록 하면 될듯
