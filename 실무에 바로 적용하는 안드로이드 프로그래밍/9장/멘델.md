# 리사이클러뷰

MVC 구조에서 액티비티, 프래그먼트, 뷰모델은 컨트롤러의 영역이다.

xml이 뷰의 영역이고,

보여줄 데이터들이 바로 모델이다.

코틀린의 mutableList에는 +연산이 add함수와 같다.

내부적으로는 ArrayList로 생성된다고 한다. 그리고 뮤터블은 인터페이스 타입일 뿐이다.

즉, 뮤터블이든 이뮤터블이든 둘다 어레이리스트인 것은 똑같다.

ViewModelProvider(this).get(CrimeListViewModel::class.java)

⇒ 앞의 절까지의 의미는 현재 해당 생명주기와 연관된 뷰모델프로바이더 객체를 생성하는 것이고

뒤의 get절은 뷰모델 객체를 얻는 것이다.

프래그먼트에서 뷰모델이 사용되어도 뷰모델의 생명주기 상태가 두 가지인 것은 바뀌지 않는다.

프래그먼트가 회전 시에도 해당 뷰모델이 죽지 않고 유지된다.

프래그먼트 객체가 소멸될 때 같이 소멸된다.

주의할 점: 만약 특정 프래그먼트 객체가 백스택에 추가되는 경우, 그 프래그먼트 객체는 소멸되지 않는다. 뷰까지만 파괴될뿐. 또한 이때 이 프래그먼트의 뷰모델도 소멸되지 않는다.

리사이클러뷰에는 닫는 태그를 사용하지 않는다(예전에 다른 크루의 미션 피드백에서 봤던 기억 있음)

## 레이아웃 매니저

리사이클러뷰는 항목들의 배치에 대한 처리, 스크롤 동작 등을 레이아웃 매니저에게 위임한다.

레이아웃 매니저도 커스텀해서 만들 수 있다고 한다.

리사이클러뷰는 뷰그룹을 상속받고 레이아웃의 종류는 아니다.

## 뷰홀더

리사이클러뷰는 항목 아이템 뷰가 뷰홀더라는 객체에 포함되어있다고 간주한다.

실제로 리사이클러뷰의 뷰홀더는 뷰에 대한 참조를 갖는다.

리사이클러뷰는 뷰홀더가 부족할 때, 항목 뷰를 만드는 것이 아니라, 그 항목 뷰에 대한 참조를 갖는 뷰홀더를 만든다.

리사이클러뷰의 뷰홀더 안에서는 뷰홀더 객체를 처음 생성할 때, 이 뷰홀더 객체가 참조하는 항목 뷰가 지닌 뷰 요소들에 대한 참조를 뷰홀더 객체가 유지한다.

## 어댑터

위에서 배운 뷰홀더를 생성하는 것은 어댑터가 담당한다.

어댑터는 컨트롤러의 역할을 하는 객체다.

리사이클러뷰와 보여줄 데이터 사이에 위치해서 말 그대로 어댑터의 역할을 해준다.

어댑터가 하는 두 가지 책임

- 뷰홀더 객체 생성
- 뷰홀더와 데이터를 바인딩

리사이클러뷰가 하는 책임

- 새 뷰홀더 객체의 생성을 어댑터에 요청
- 지정된 위치의 데이터 항목에 뷰홀더를 바인딩하도록 어댑터에 요청

⇒ 즉, 리사이클러뷰는 어댑터에게 요청을 할 뿐이다.

리사이클러뷰 자체는 자신이 보여주는 데이터들의 구체적인 정보를 모른다. 어댑터만 안다.

데이터가 담긴 어댑터 객체를 만들고, 이걸 리사이클러뷰의 어댑터 속성에 넣어주면 된다.

그러면 리사이클러뷰에 항목뷰들이 보인다.

onBindViewHolder에서는 최소한의 일만 해야 한다.

그래야 스크롤할 경우 부드럽게 넘어간다.

어댑터의 바인딩함수에서 직접 바인딩 시키지말자.

왜? ⇒ 바인딩은 홀더가 할 역할이다. 자신이 참조하고 있는 항목뷰의 뷰들에 직접 연결시키는 것을 말하는 것이다.

즉, 어댑터와 홀더의 역할을 정확히 분리시키기 위해서 어댑터 안에서 연결하지 말라는 것임.

## 리사이클러뷰에 이벤트 리스너 달기

리사이클러뷰는 레이아웃매니저,어댑터,뷰홀더에게 거의 모든 책임을 넘기고 있다.

즉, 실질적으로 리사이클러뷰가 하는 것은 없이 요청만 하고 있다.

이벤트도 뷰홀더에게 넘겨서 처리한다.

⇒ 일단 뷰홀더를 View.OnClickListener 인터페이스를 구현시키자. 이 안에서 onClick 메소드를 원하는대로 구현하면 된다. 다만, 여기서는 뷰홀더 안에서 구체적인 처리를하고 있다. 이도 별로 좋지는 않은 방법같다. onClick 메소드안의 상세 구현 내용은 외부로부터 받는게 좋을지도?

# 기존의 리스트뷰,그리드뷰와의 차이

항목 뷰를 생성하는것은 어댑터가 책임진다. 이것은 똑같음.

하지만, 뷰홀더 패턴을 강제하지 않기 때문에 항목뷰로부터 매번 findViewById를 사용해서 불러와야 한다.

→ 이는 레이아웃의 깊이가 깊을수록 오래걸린다.

리사이클러뷰에는 또한 기본적인 애니메이션도 들어가 있다. 또한, 커스터마이징도 쉽다.

리스트의 0번 인덱스 데이터가 5번 인덱스 위치로 움직이는 것을 보고 싶다면, 다음과 같이 해라.

**recyclerView.adapter.notifyItemMoved(0,5)**

## 뷰타입을 활용해서 다양한 종류의 항목뷰를 보여줄 수 있다
